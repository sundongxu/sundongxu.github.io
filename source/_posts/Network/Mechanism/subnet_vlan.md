---
title: 子网与VLAN
date: 2017-11-05 21:06:06
categories:
- Network
tags:
- Subnet
- VLAN
---

## 全文概要



<!--more-->

## 子网

网络/网段与子网的区别

IP地址与子网掩码作按位与运算结果是网络号

通过计算机的子网掩码判断两台计算机是否属于同一网段的方法是：

> 将计算机十进制的IP地址和子网掩码转换为二进制的形式，然后进行二进制按位与计算(全1则得1，不全1则得0)，如果得出的结果是相同的，那么这两台计算机就属于**同一网段**。

通俗来说就是位于同一个局域网内，可以两两ping通，在已知网络IP地址但不知道MAC地址情况下，可以通过广播ARP请求及获取ARP应答的方式构建新ARP表项，在通信发起方处维护对端IP地址到其MAC地址的映射。

如果属于同一网络区间，这两个地址间的信息交换就不通过**路由器**。如果不属同一网络区间，也就是子网号不同，两个地址的信息交换就要通过**路由器**进行。

---

### 从Ping说起吧

现有两台服务器A和B，具体配置信息如下表：

| Server ID |   IP Address   |     Subnet Mask     | Default Gateway |        MAC        |
| :-------: | :------------: | :-----------------: | :-------------: | :---------------: |
| Server A  | 192.168.26.129 |  **255.255.255.0**  |  192.168.26.2   | 08:00:27:28:b9:11 |
| Server B  |  192.168.26.3  | **255.255.255.224** |  192.168.26.2   | 08:00:27:28:b9:22 |

默认网关IP：192.168.26.2/24，MAC地址：08:00:27:28:b9:33

问题描述如下：

> B的子网掩码本来应该配成255.255.255.0，但不小心配成了255.255.255.224，那么A与B还能正常通信嘛？
>
> - 如果不行，说明原因。
> - 如果可以，请简述通信流程。

以上是我很欣赏的一本书《Wireshark网络分析就是这么简单》开篇提出的一个面试题，初看问题，心想好歹也是计算机专业学生，大三算是很认真学习过计算机网络这门专业课，且不说研究多么深入，但至少对于基础概念或问题，如OSI分层模型、TCP可靠传输机制、子网划分、路由算法甚至CSMA都如数家珍(毕竟好像教科书上科普重点就这么多...)，小小的一个**ping**得通还是**ping**不通的问题，还能难倒我？

好吧，我承认，好像真的看蒙了。

书上给出四个**Plausible**的答案，乍一看，真都好有道理：

> - 版本一
>   - 答案：“A与B不能通信，因为…这都行的话，子网掩码还有什么用？？？”
>   - 评价：这位的反证法听上去让人无从置疑！
> - 版本二
>   - 答案：“A与B可以通信，因为它们通过ARP广播获知对方MAC地址。”
>   - 评价：那子网掩码有什么用？上面的反证法刚好可用来反驳这位。
> - 版本三
>   - 答案：“A与B可以通信，但所有包都要通过默认网关192.168.26.2转发。”
>   - 评价：请问这么复杂的结果你是怎么想到的？
> - 版本四
>   - 答案：“A与B不能通信，因为ARP不能跨子网。”
>   - 评价：这个答案倒像是过了脑子的。

关于以上问题的事实：真相只有一个。

而事实有时候就很残酷：上面一个都不对。

解释说明题可与选择题不一样，后者结论对了找准选项就能拿满分，前者即使给出正确结论，但是荒谬无稽的解释则常常给阅卷人想要倒扣分的冲动…好吧，可能我想得比较极端了。

按照正经答题的顺序，先告诉你正确答案：A与B可以通信。

接下来看看这个过程中发生了什么，以**B ping A**为例，至于为什么不是**A ping B**，请认真阅读下文内容，在之后我会解释原因。

要得出这个答案，我在Virtualbox上拿VM搭了个简单网络拓扑，两个VM分别作为Server A和Server B，第三个VM作为默认网关，并设置成允许转发：

> echo 1 > /proc/sys/net/ipv4/ip_forward

得到的抓包结果如下图所示：

{% qnimg Network/Mechanism/wireshark-ping-arp.png %}

{% qnimg Network/Mechanism/wireshark-ping-icmp.png %}

那么根据以上Wireshark的抓包结果，按数据包出现顺序，可以将**B ping A**的通信流程作如下分析：

1. 在B处，计算B的IP地址，即**源IP地址**，与A的IP地址，即**目的IP地址**，分别和B的子网掩码**按位与**的结果，即应用上文介绍的计算网络地址的唯一方法，发现：B对应的网络地址为192.168.26.0，而A对应的网络地址为192.168.26.128，结果不同，因此B会据此判断：本机与目的主机A不在同一网段。而不在同一网段的主机要进行通信，参考前文中关于跨网络通信的机制的内容，了解到B要想与A通信，必须经过**默认网关**(肯定与本机B在同一网段)的转发，故主机B会先把ICMP数据包发往默认网关192.168.26.2，我们知道要发送一个数据包，仅知道目的IP地址是不够的，真正在链路上传输时，目的主机的物理地址即MAC地址也是必须要一同封装在以太网帧中的，然而初始时并不知道默认网关的MAC地址，ARP协议的作用正在于此：B向本网段广播(ff:ff:ff:ff:ff:ff)一个ARP Request包，询问：“谁的IP地址是默认网关的地址，请把你的MAC地址回复给我”——本次通信的**第一个数据包出现**了！
2. 默认网关接收到此ARP请求后检查目的IP发现就是自己，于是将自己的MAC封装在ARP Reply数据包中回复给主机B，这是**第二个数据包**。
3. 主机B获知默认网关的MAC地址后，发送一个ICMP数据包给它，**第三个数据包**被发送，其实这个包本意是想发送给主机A，但中间需要默认网关帮忙中转一下，故此ICMP包的目的MAC地址为默认网关的MAC地址，但是目的IP地址仍为主机A的IP地址。至于包是不是被默认网关转发了，还不得而知，除非在默认网关处也抓到个包。
4. 然后我们在主机B上抓到了**第四个数据包**，居然又是个ARP请求包，根据源MAC地址显示，这个ARP请求来自主机A，那么它想干什么？包内容显示该请求想知道：谁的IP是192.168.26.3，也就是，谁是主机B？
   - 在A处重复流程1中的IP地址与网络掩码的**按位与**运算，不过这次的网络掩码要用主机A的掩码，发现：A对应的网络地址为192.168.26.0，而B对应的网络地址竟然也是192.168.26.0！
   - 你为什么会这么震惊？
   - 你是不是发现了什么不得了的事儿？
   - 没错，你已经知道了另一个事实：在A看来，本机与目的主机B在同一网段！从而A要主动向B发包的话，在知道其MAC地址的前提下，是可以直接发送而无需默认网关转发的。但好像又有不对劲的地方…容我反应一下...
   - 你马上想到一个问题：A为什么会要给B发包？
   - 我猜你问出这个问题的下一秒，已经知道了答案：当然是因为A已经收到了B的ping包，而A在想要回复B一个ICMP包时候发现自己并不知道主机B的MAC地址呀！
   - 这间接证明了在流程3中，默认网关确实将B发送给它的那个目的IP地址为A的IP地址的ICMP包，正确地转发给了A。
5. 至于**第五个数据包**，当然是主机B回复主机A的ARP请求的ARP Reply，将自己MAC地址告诉主机A，方便主机A响应此前自己的ping操作。
   - 这就又证明了一件事儿：主机B在执行ARP回复时并不考虑子网，这不，虽然ARP请求在它看来，来自另一个子网的IP地址，但也照样回复。
6. 之后，主机B终于收到了来自A的ICMP回包，即在抓到**第六个相关数据包**后，一次ping过程成功完成。
7. 后来的过程中，主机A、B由于清楚地知道了对方的联系方式(各自以及默认网关的IP地址、MAC地址以及路由信息)，此后的就没必要再发ARP包了，于是此后都是直接抓到双方由于ping产生ICMP数据包。

分析完这几个包，面试题的答案有了，原来通信流程是这样：B先把ping请求交给默认网关，默认网关再转发给A，而A收到请求后直接把ping回复给B，形成如下所示的三角环路：

{% qnimg Network/Mechanism/triangle-loop.png %}

让我们再回到之前的那个问题：为什么以**B ping A**为例，而不是**A ping B**呢？

其实答案已经一目了然：将**B ping A**的结果从第五个数据包到第一个数据包顺序颠倒，再加上之后的第六、七…个数据包，就是**A ping B**的通信流程。

