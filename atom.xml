<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sun Dongxu&#39;s Blog</title>
  
  <subtitle>Reorganizing the Organization, Rebuilding the Building.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="dongdongdong.me/"/>
  <updated>2017-12-06T07:17:40.595Z</updated>
  <id>dongdongdong.me/</id>
  
  <author>
    <name>Sun Dongxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>转发表(MAC表)、ARP表、路由表总结</title>
    <link href="dongdongdong.me/2017/11/07/Network/Mechanism/forwarding_mac_routing/"/>
    <id>dongdongdong.me/2017/11/07/Network/Mechanism/forwarding_mac_routing/</id>
    <published>2017-11-06T16:22:25.000Z</published>
    <updated>2017-12-06T07:17:40.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全文概要"><a href="#全文概要" class="headerlink" title="全文概要"></a>全文概要</h2><p>计算机网络中一个关键步骤在于通信路径上不同节点对于流经本节点的数据包转发，常见的交换设备主要是交换机(第二层、三层)和路由器(第三层)，在实际运行时，它们各自维护一些表结构帮助完成数据包的正确寻址与转发，本文详细介绍了三张至关重要的表：转发表、ARP表与路由表的在网络数据包转发功能中发挥的作用，以及它们协同工作的原理，顺便也会接着<a href="http://dongdongdong.me/2017/10/30/Network/Hardware/relay/"><strong>之前的文章</strong></a>继续谈谈交换机和路由器的一些事儿。</p><a id="more"></a><h2 id="网络分层协议"><a href="#网络分层协议" class="headerlink" title="网络分层协议"></a>网络分层协议</h2><hr><p>计算机网络是将地理上隔离的计算节点从物理上相连(双绞线、光纤、无线信号等)，并采用分层方式，将计算机网络自顶向下依次分为五层：应用层-&gt;传输层-&gt;网络层-&gt;数据链路层-&gt;物理层，对应设计有一整套网络协议栈，各层次分别运行有多种协议，下层向紧邻上层提供服务并隐藏通信细节，上层调用紧邻下层提供的服务，完成主机不同层次之间的对等通信，高层(应用层、传输层、网络层)之间借此实现逻辑相连通信。之所以称为“逻辑通信”，是因为不同主机相同的较高层次之间好像是沿水平方向传送数据，但事实上这两个对等层次之间并没有一条水平方向的物理连接，举例说明如下：</p><ol><li><strong>传输层协议</strong>用于实现<strong>应用进程间</strong>逻辑通信，这是因为<strong>进程</strong>本来就是便于资源分配与管理而发明的<strong>逻辑概念</strong>，并不是<strong>物理实体</strong>，无法从物理上产生关联；</li><li><p><strong>网络层协议</strong>用于实现<strong>主机间</strong>逻辑通信，这是因为两个<strong>通信主机</strong>通常位处网络拓扑中的不同位置，大多时候并非直接从物理上相连，之间需要一条根据<strong>路由协议</strong>选路确定的通信路径，网络层协议负责数据包最终能够发送给目的主机，但向上(即给运输层)只提供尽力而为(Best-Effort)的数据包服务；</p></li><li><p><strong>数据链路层</strong>用于实现<strong>点到点通信</strong>，由于不同节点在物理上通过真实的数据链路相连，不能再算是逻辑通信。</p></li></ol><h2 id="转发表-Forwarding-Table"><a href="#转发表-Forwarding-Table" class="headerlink" title="转发表(Forwarding Table)"></a>转发表(Forwarding Table)</h2><hr><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址(Media Access Control Address)，即媒体访问控制地址，通常也称为以太网地址或物理地址，它是一个用于确认网络设备位置的地址，每个网络设备(如网络适配器(Network Adapter)，即网卡(Network Interface Card, NIC))都有世上唯一的MAC地址，一台设备若有多张网卡，则每个网卡都必须具有一个唯一的MAC地址，这个是在网络设备出厂时由厂商烧制确定。</p><p>MAC地址共48位，即6个字节，通常每4位构成一个16进制数，从而可以表示成xx:xx:xx:xx:xx:xx的形式，每个x都是一个16进制数。其中ff:ff:ff:ff:ff:ff为广播地址，以此作为目的地址的数据包会被交换机广播至全部端口，发到与其端口相连的全部局域网;01:xx:xx:xx:xx:xx是多播地址。</p><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>转发表，又称MAC表，聊到它就不得不提到交换机里，因为交换机就是根据转发表来转发数据帧的。</p><p>交换机本质上也是一个计算机，拥有计算(CPU)、存储(SRAM或TCAM)和网络资源(转发芯片和链路)，甚至还会安装专用操作系统，它会维护一张记录着局域网主机端口MAC地址与交换机端口对应的表，交换机就是根据这张表负责将数据帧传输到指定的主机端口上的。</p><p>交换机具有“<strong>存储转发</strong>”功能：</p><ul><li><p>交换机在接收到数据帧以后，首先会记录数据帧中的源MAC地址和对应的到达端口到MAC表中，这一过程通常称为“自学习”，不需要任何的人工干预；</p></li><li><p>接着，交换机检查自己的MAC表是否有数据帧中目的MAC地址的匹配条目，如果有，则会根据MAC表中记录的对应端口将数据帧转发出去，这一转发方式称为“单播”(Unicast)。而如果没有，则会将该数据帧从非达到端口的其它全部端口发送出去，这一转发方式程序称为“广播”(Broadcast)。</p></li></ul><p>下面会以图示的方式详细讲解交换机传输数据帧的过程，下面先来看看单个交换机转发的情形：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Hardware/forwarding-single-switch.png"><p>步骤如下：</p><ol><li>主机A会将一个源MAC地址为本机网卡物理地址，目的MAC地址为主机B网卡物理地址的数据帧发送给交换机1；</li><li>交换机收到此数据帧后，首先将数据帧中的源MAC地址和对应的输入端口0记录到交换机维护的MAC地址表中；</li><li>然后交换机会检查自己的MAC地址表中是否有数据帧中的目的MAC地址的信息，如果有，则从MAC地址表中记录的对应端口发送出去，如果没有，则会将此数据帧从非接收端口的所有端口发送出去，这里仅从端口1发出；</li><li>这时，局域网的所有主机(通过交换机相连的全部主机)都会收到此数据帧，但是只有主机B收到此数据帧时会响应这个广播帧，并回应一个数据帧(这个回应由什么机制确定的，需要再查资料确定一下～TCP的ACK包？)，此数据帧中包括主机B网络设备的MAC地址；</li><li>当交换机收到主机B回应的数据帧后，也会记录数据帧中的源MAC地址，即主机B网络设备的MAC地址，这时，再当主机A和主机B相互通信时，交换机就根据MAC地址表中的记录，实现单播了，一趟转发流程实际交换机就“学习”到了两个转发表条目。</li></ol><p>那么当局域网内存在多个交换机互连的时候，交换机的MAC地址表是如何记录的呢？下图就展示了该种情形：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Hardware/forwarding-multiple-switch.png"><p>步骤如下：</p><ol><li>主机A将一个源MAC地址为本机网卡物理地址，目的MAC地址为主机C网卡物理地址的数据帧发送给交换机1；</li><li>交换机1收到此数据帧后，会学习源MAC地址，并检查MAC地址表，发现没有目的MAC地址的记录，则会将数据帧广播出去，主机B和交换机2都会收到此数据帧；</li><li>交换机2收到此数据帧后也会将数据帧中的源MAC地址和对应的端口记录到MAC地址表中，并检查自己的MAC地址表，发现没有目的MAC地址的记录，则会广播此数据帧，主机C和主机D都会收到此数据帧；</li><li>主机C收到数据帧后，会响应这个数据帧，并回复一个源MAC地址为本机网卡物理地址的数据帧，该帧最终会送往主机A，这时交换机1和交换机2都会将主机C的MAC地址记录到自己的MAC地址表中，并且以单播的形式将此数据帧发送给主机A；</li><li>这时，主机A和主机C通信就可以以单播的形式传输数据帧了，A与D、B与C及B与D的通信与上述过程一样，因此交换机2的MAC地址表中记录着主机A和主机B的MAC地址都对应其端口3。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从以上两幅图可以看出，交换机具有动态自学习源MAC地址与物理端口映射的功能，并且交换机的一个端口可以对应多个MAC地址，但是一个MAC地址只能对应一个端口。</p><p>注：交换机动态学习的MAC地址默认只有300s的有效期，如果300s内记录的MAC地址没有对应的通信过程来更新对应条目，则会自动删除此记录，这是由交换机中的一个计时器所维护的。</p><h2 id="ARP表-Address-Resolution-Table"><a href="#ARP表-Address-Resolution-Table" class="headerlink" title="ARP表(Address Resolution Table)"></a>ARP表(Address Resolution Table)</h2><hr><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>首先明确一点，<strong>在以太网环境下，同一个网段的主机之间需要知道对方的MAC地址，才能进行通信</strong>。</p><p>上一节介绍了交换机的工作原理，了解到交换机是根据MAC寻址，查表确认输出端口以完成本节点转发任务的。看到这里其实应该可以抛出从一开始就被我们忽视了的问题：在初始构造数据包准备发送时，源主机究竟要如何获得目的主机网络设备MAC地址的呢？这时，就需要使用到ARP协议。在网络拓扑中的每个节点或说主机上，实际都维护有一张ARP表，它记录着主机的IP地址(网络地址)到MAC地址(物理地址)的映射关系。</p><p>ARP协议，即地址解析协议，它是一个网络层协议，运行在各网络节点上，负责完成主机IP地址到MAC地址的映射。</p><h3 id="工作流-1"><a href="#工作流-1" class="headerlink" title="工作流"></a>工作流</h3><p>接下来根据下图，详细讲解一下ARP协议的工作原理：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Hardware/arp-protocol.png"><p>步骤如下：</p><ol><li>如果主机A想发送数据包给同一网段内的另一台主机B(通过交换机相连的节点处于同一网段)，很明显，A的用户应用程序要么已经知道B的IP地址，或者说域名(Domain Name，DNS协议会完成主机名到IP地址的映射，这里不是重点)，那么主机A首先会检查自己的ARP缓存表(ARP Cache)，查看是否有主机B的IP地址与其MAC地址的对应关系，如果有，则直接将主机B网络设备的MAC地址作为目的MAC地址封装到数据帧中，无需进一步操作即获取到数据帧封装所需的全部信息，此后完成封装并发送数据帧到目的MAC地址。如果没有，主机A则会发送一个ARP请求信息(ARP Request)，请求的目的IP地址是主机B的IP地址，目的MAC地址是MAC层的广播地址(即ff:ff:ff:ff:ff:ff)，源IP地址和MAC地址是主机A的IP地址及其MAC地址；</li><li>当交换机接收到此数据帧之后，发现此帧是广播帧，因此，会将此数据帧从非接收的所有端口发送出去；</li><li>同一网段中的所有节点都会接收到该ARP请求数据包，目的IP不匹配的节点会直接忽略该请求，而当主机B接收到此数据帧后，解析到IP地址与自己的IP地址一致，先将主机A的IP地址及其MAC地址的对应关系记录到自己的ARP缓存表中，同时会发送一个ARP应答(ARP Response)，应答数据包源MAC地址即主机B自身网络设备的MAC地址，该应答通过交换机转发至主机A；</li><li>主机A在收到这个回应的数据帧之后，在自己的ARP缓存表中记录主机B的IP地址和MAC地址的对应关系。而此时主机A已经可以继续封装准备发往主机B的数据帧，而交换机也已经学习到了主机A和主机B的MAC地址与其端口的对应关系，之后主机A发送的数据帧通过交换机转发至主机B。</li></ol><p><strong>这里有一点值得注意的是</strong>传输过程中IP地址与MAC的地址的变化问题：</p><ul><li>MAC地址在同一个广播域中传播时始终不变，但在跨越广播域(即经过路由器)时，会由于重新封装而改变，源MAC地址将变为路由器的输出端口的MAC地址，目的MAC地址随网络拓扑实际情况而定，若路由器与目的主机所在网段直连，此时目的MAC地址就是目的主机的MAC地址；而不管是源IP地址还是目的IP地址，在数据包传输过程中都始终不会改变。</li></ul><!--主机A在构造数据帧准备发送给主机B时，源IP地址和源MAC地址分别是自己的IP地址和MAC地址，但是目的IP地址和目的MAC地址则应该是主机B的对应地址，但是由于A与B不是直接通过链路相连，通信路径上还需经过若干转发设备，如交换机，因为MAC层即数据链路层只负责链路两端点之间的数据传输，且交换机通常具有“存储转发”功能，即其在接收到一个数据包后会将其短暂存储，历经解包和再次打包成帧(Framing)的过程，根据其上维护的MAC表查到对应目的MAC地址的输出端口将其转发。此时转发出去的数据帧有效载荷(Payload, 数据帧=以太网头部+网络层数据报，即帧有效载荷实际就是网络层数据报)不会改变，这是因为交换机工作在数据链路层，在解析数据包的时候不会涉及到网络层及以上层次的协议字段。但是由于重新打包步骤的存在，导致以太网头部中的源MAC地址将会被交换机修改为其自身的硬件MAC地址，目的MAC地址则依然不会改变，之后从输出端口推向链路进行传输。--><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>网络中每个节点都会通过运行ARP协议而维护节点内部的一张ARP缓存表，用于完成从IP地址到MAC地址的映射，在发送数据之前往往会先查询本地ARP表中对应目的IP地址的MAC地址，若没有表项则会发起ARP广播请求直至获取对应主机响应并发来应答，将该应答中包含的目的IP地址与MAC地址的映射关系添加到ARP缓存表之后，在数据链路层就可以以该MAC地址为目的MAC地址封装数据帧并发送。</p><h2 id="路由表-Routing-Table"><a href="#路由表-Routing-Table" class="headerlink" title="路由表(Routing Table)"></a>路由表(Routing Table)</h2><hr><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址(Internet Protocol Address)，即互联网协议地址，也称为网络层地址或主机地址，是分配给网络上的各个网络设备的地址。</p><p>现在流行的IP协议有两个版本：IPv4(Internet Protocol Version 4)和IPv6(Internet Protocol Version 6)。其中，IPv4地址为32位，即4个字节，为便于使用，常以xxx.xxx.xxx.xxx每个字节8位从二进制表示为十进制数，这种表示方法称为点分十进制，地址可分为A、B、C、D、E五大类，32位全为1的IP地址：255.255.255.255称为“受限广播地址”(Limited Broadcasr Destination Address)，用于将一个分组以广播方式发送给本网络中的所有主机，路由器则阻挡该分组通过，将其广播功能限制在本网内部，因此可以说路由器隔离了广播域(交换机隔离了冲突域)。</p><p>随着网络规模和节点数量的不断扩展，出于32位的IPv4将很快被分配使用殆尽的担忧，又推出了IPv6地址，128位，16个字节，通常每4位表示为一个16进制数，16个字节分为8组，每组包含2个字节即4个16进制数，组与组之间以冒号分割：ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff为IPv6协议下的广播地址。</p><h3 id="IP-VS-MAC"><a href="#IP-VS-MAC" class="headerlink" title="IP VS MAC"></a>IP VS MAC</h3><p>其实MAC地址和IP地址本质上都是网络设备物理端口的性质，都可以用于寻址网络设备，但如果它们功能类似，只是工作的层次不同的话，两者之间应该可以通过某种机制实现相互替换，但为什么它们共存至今呢？</p><p>对于MAC地址和IP地址的比较，有人曾这么比喻：一个人已经有了手机号(IP地址)，为什么还要有身份证号呢(MAC地址)？身份证号是一个人的唯一标识号，只要有这个号码就能找到该人，但是为啥他的朋友们不用身份证号来寻找该人而用手机号呢？对，因为方便。但是如果该人犯罪，警察用手机号呼叫寻找该人，傻子才会接吧…而且换了号码怎么办？那不就得用你的身份证号在全国发布通缉令，利用身份证号在全国各种系统范围(消费、社交、医疗)内搜索该人的记录，才能最终定位该人实施有效逮捕嘛。</p><p>上述例子实际就契合了两种地址存在的意义：IP地址是逻辑地址，根据网络协议，在不同的地理位置加入互联网就会分配到完全不同的IP地址(DHCP动态分配IP地址)，但由于属于网络层，相对较高的抽象层次设计的初衷就是为了简化通信，方便使用，尤其对于用户进程而言；MAC地址是物理地址，工作在数据链路层，一旦出厂时由厂商确定并烧制入网络设备的EPROM中就具有了固定的全球唯一的地址，任何时候任何条件都不会改变，虽说使用起来不太方便，且描述的是较低层的数据链路通信细节，但在任何时候都可用于数据通信寻址。</p><p>更严谨完善的解释如下：</p><blockquote><p>问题：既然每个以太网设备在出厂时都有一个唯一的MAC地址了，那为什么还需要为每台主机再分配一个IP地址呢？或者说为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，路由器等）生产时内嵌一个唯一的MAC地址呢？</p><p>解答：主要原因基于以下几点：<br>（1）IP地址的分配是根据网络的拓扑结构，而不是根据谁制造了网络设置。若将高效的路由选择方案建立在设备制造商的基础上而不是网络所处的拓扑位置基础上，这种方案是不可行的；<br>（2）当存在一个附加层的地址寻址时，设备更易于移动和维修。例如，如果一个以太网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡；<br>（3）无论是局域网，还是广域网中的计算机之间的通信，最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由ARP协议负责将IP地址映射到MAC地址上来完成的。</p></blockquote><p>下面再通过一个例子看看IP地址和MAC地址是怎样结合起来传送数据包的：</p><blockquote><p>假设网络上要将一个数据包（名为PAC）由北京的一台主机（名称为A，IP地址为IP_A，MAC地址为MAC_A）发送到纽约的一台主机（名称为B，IP地址为IP_B，MAC地址为MAC_B）。这两台主机之间不太可能是直连起来的，因而数据包在传递时必然要经过许多中间节点(如路由器，网关服务器等)，假定在传输过程中要经过C1、C2、C3(其输入、输出端口的MAC地址分别为M1_In/M1_Out，M2_In/M2_Out，M3_In/M3_Out)三个节点。A在将PAC发出之前，先发送一个ARP请求，找到其要到达IP_B所必须经历的第一个中间节点C1的到达端口MAC地址M1_In，然后在其数据包中封装地址：IP_A、IP_B，MAC_A和M1_In。当PAC传到C1后，再由ARP根据其目的IP地址IP_B，找到其要经历的第二个中间节点C2的到达端口MAC地址M2_In，然后再封装目的MAC地址为M2_Out的数据包传送到C2。如此类推，直到最后找到IP地址为IP_B的B主机的MAC地址MAC_B，最终传送给主机B。在传输过程中，数据包源IP地址IP_A、目的IP地址IP_B不变，而源MAC地址和目的MAC地址，由于中间节点重新封装数据帧而不断改变，直至目的地址MAC地址为MAC_B，数据包最终到达目的主机B。</p></blockquote><p>综上所述，IP地址和MAC地址相同点是它们都可以作为设备地址标识，不同的特点则主要有以下几个方面：</p><ol><li>对于网络上的某一设备，如一台计算机或一台路由器，其IP地址可变（但必须唯一），而MAC地址不可变。我们可以根据需要给一台主机指定任意的IP地址，如我们可以给局域网上的某台计算机分配IP地址为192.168.0.112 ，也可以将它改成192.168.0.200。而任一网络设备（如网卡，路由器）一旦生产出来以后，其MAC地址永远唯一且不能由用户改变；</li><li>长度不同。IP地址为32位4字节，MAC地址为48位6字节；</li><li>分配依据不同。IP地址的分配是<strong>基于网络拓朴</strong>，MAC地址的分配是<strong>基于制造商</strong>；</li><li>寻址协议层不同。IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到同一段链路的另一个节点上(通过MAC地址寻址)，而网络层协议使数据可以从一个网络传递到另一个网络上(ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点转发，从而最终到达目的网络)。</li></ol><h3 id="工作流-2"><a href="#工作流-2" class="headerlink" title="工作流"></a>工作流</h3><p>路由器负责不同网段(Subnet, 子网)之间的通信，每个与路由器端口相连的网络被称为一个子网或网段，也就是一个广播域。在路由器中也有一张表，这张表叫做路由表，通过在网络节点上运行路由协议，记录并更新去往不同网段的路径信息。路由表中的信息分为直连路由和非直连路由：</p><ul><li><strong>直连路由</strong>：直接连接到路由器端口的网段，该信息由路由器自动生成；</li><li><strong>非直连路由</strong>：不是直接连接到路由器端口的网段，此记录需要手动添加或使用动态路由生成。</li></ul><p>本机Linux系统下, 双网卡em1(114.212.84.179)与virbr0(192.168.122.1)，执行命令：route -n，获取内核IP路由表如下：</p><style>table th:nth-of-type(1) {    width: 100px;}</style><style>table th:nth-of-type(2) {    width: 100px;}</style><style>table th:nth-of-type(3) {    width: 100px;}</style><table><thead><tr><th>Destination</th><th>Gateway</th><th>Genmask</th><th>Flags</th><th>Metric</th><th>Ref</th><th>Use</th><th>Iface</th></tr></thead><tbody><tr><td>114.212.80.0</td><td>0.0.0.0</td><td>255.255.248.0</td><td>U</td><td>100</td><td>0</td><td>0</td><td>em1</td></tr><tr><td>192.168.122.0</td><td>0.0.0.0</td><td>255.255.255.0</td><td>U</td><td>0</td><td>0</td><td>0</td><td>virbr0</td></tr><tr><td>0.0.0.0</td><td>114.212.80.1</td><td>0.0.0.0</td><td>UG</td><td>100</td><td>0</td><td>0</td><td>em1</td></tr></tbody></table><p>解析上述路由表：</p><blockquote><p>第一项：目的网络为114.212.80.0/21，网关地址为0.0.0.0，这表示该网段属于与路由器某端口直连的网段，数据包将从路由器em1接口输出；</p><p>第二项：目的网络为192.168.122.0/24，网关地址同样为0.0.0.0，表示该网段属于与路由器某端口直连的网段，数据包将从路由器virbr0接口输出；</p><p>第三项：目的网络为0.0.0.0时，即匹配任意网段，由于路由表匹配执行最先匹配策略，第三项就是当目的IP地址无法与前两项匹配时的成功匹配项，对应的网关称为默认网关，即路由器中没有存储某个目的网络的表项时应该转发至的下一跳地址，从em1端口输出。</p></blockquote><p>路由器中记录的条目有的需要手动添加，称为静态路由；有的则是动态获取的，称为动态路由。表中的每个条目都有以下属性：</p><ol><li><p><strong>目的网络地址(Destination)</strong>：网络地址和网络掩码相与的结果用于定义本机可以达到的目的网络范围，通常情况下，目的网络范围包含以下几种情况：<br> (1) <strong>主机地址</strong>：某个特定主机的网络地址；<br> (2) <strong>子网地址</strong>：某个特定子网的网络地址；<br> (3) <strong>默认路由</strong>：所有未在路由表中指定的网络地址，用0.0.0.0统一匹配，用于配置默认网关；</p></li><li><p><strong>网络掩码(Genmask)</strong>：又称为子网掩码(Subnet Mask)，是一个32位地址，作用是将一个同样也是32位的IPv4地址划分成网络地址(Network Address)和主机地址(Host Address)。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码是用来判断任意两台主机是否处于同一网段的根据，简单来说就是两台主机各自的IP地址与本机配置的子网掩码做按位与操作，如果结果相同，则说明这两台主机是处于同一网段，可以进行直接的通讯，而无需路由器的转发；</p></li><li><p><strong>网关(Gateway，又被称为下一跳服务器(Next Hop Server))</strong>：发送IP数据包时，网关定义了针对特定的网络目的地址，数据包将要被发送到的下一跳IP地址。如果是与路由器直接相连的网段，网关通常就是路由器对应的网络端口的IP地址，但是此时接口必须与网关一致。如果是远程网络或默认路由，网关通常是与路由器相连网络上的某个服务器或路由器。如果目标是本主机所属网络，不需要路由，网关显示为”*“;</p></li><li><p><strong>接口(Iface)</strong>：接口定义了针对特定的网络目的地址，路由器用于转发数据包的网络接口(路由器的物理端口)。网关必须位于和接口相同的子网(默认网关除外)，否则造成在使用此路由项时需调用其他路由项，从而可能会导致路由死锁;</p></li><li><p><strong>跳数(Metric)</strong>：跳数用于指出路由的成本，通常情况下代表到达目标地址所需要的总跳数，一个跳数代表经过一个路由器，IP数据报首部中的TTL字段就是该数据报所能存活的总跳数。跳数越少往往代表着该路由成本越低，跳数越多则说明成本越高。当具有多条达到相同目的网络的路由选项时，路由算法会选择具有更少跳数的路由。</p></li><li><p><strong>标志(Flags)</strong>：多种路由表项标记含义如下：<br> (1) U：路由是动态的；<br> (2) H：目标是一个主机；<br> (3) G：路由指向网关；<br> (4) R：恢复动态路由产生的表项；<br> (5) D：由路由的后台程序动态安装；<br> (6) M：由路由的后台程序修改；<br> (7) !：拒绝路由。</p></li><li><p><strong>引用次数(Refs)</strong>：Linux内核中未使用，一般是0；</p></li><li><p><strong>查找次数(Use)</strong>：此路由项被路由软件查找的次数。</p></li></ol><p>路由器是工作在网络层的，在网络层可以识别逻辑地址，即IP地址，也就是说数据包解析时最多可将数据帧拆包成IP数据包，路由器无法操作数据报的载荷字段，但是可以针对IP首部做些事情：当路由器的某个端口收到一个包时，路由器就会读取包中的目地IP地址，然后在路由表中进行查找。如果在路由表中找到目的IP地址对应条目，则把包转发到路由器的对应端口。如果没找到，那么如果路由器配置默认路由(默认网关)，就默认将所有无法解析的目的网段主机的数据包都先发往该默认网关做进一步转发，如果没有配置默认路由，则将该包丢弃，并返回源主机以不可达(Unreachable)的信息。这就是数据包路由的过程。</p><p>利用下图详细介绍路由器的工作原理：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Hardware/routing-mac-frame.png"><p>步骤如下：</p><ol><li>主机A在网络层将来自上层的报文封装成IP数据报，IP首部中的源IP地址为自己的IP地址，目的IP地址为主机B的IP地址。主机A会用本机配置的24位子网掩码与目的地址进行“与”运算，得出目的地址与本机不在同一个网段(主机A位于192.168.1.0/24网段，主机B位于192.168.2.0/24网段，或称属于不同子网)，因此发送给主机B的数据包需要经过网关路由器1的转发；</li><li>主机A通过ARP请求获得网关路由器1的E0端口的MAC地址，并在数据链路层将路由器E0端口的MAC地址封装成以太网帧首部中的目的MAC地址，源MAC地址是自己的MAC地址，随后发送数据帧给路由器1；</li><li>路由器1从端口E0接收到该数据帧，随后执行解析，将数据链路层的首部剥落去掉，并在路由表中检查是否有目的IP地址的网段对应表项(即192.168.2.2/24和其所在192.168.2.0/24网段)，根据路由表中记录，发往192.168.2.0/24网段(中主机)的数据包的下一跳(Next Hop)或称网关地址为10.1.1.2/8(实际是路由器2的E1端口的IP地址)，而路由器发现下一跳地址正好位处与自己E1端口直连的网段(10.0.0.0/8)，于是数据在路由器1的E1端口重新封装，此时，以太网帧的源MAC地址是路由器1的E1端口的MAC地址，目的MAC地址则是路由器2的E1端口的MAC地址，通过ARP广播得到，封装完毕发送数据帧给路由器2；</li><li>路由器2从端口E1接收到该数据帧，随后执行解析，将数据链路层的首部剥落去掉，对目的IP地址进行检测，并与路由表进行匹配，此时发现目的主机IP地址所在网段正好是自己E0端口的直连网段，路由器2于是通过ARP广播，获知主机B的MAC地址，此时数据包在路由器2的E0端口再次封装，源MAC地址是路由器2的E0端口的MAC地址，目的MAC地址是主机B的MAC地址，随后发送数据帧给主机B；</li><li>完成以上1~4，主机B终于接收到来自主机A的数据包。</li></ol><p>综上，看似较为“简单”的跨网段主机通信，真也不是太容易的一件事儿。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>路由表负责记录一个网络到另一个网络的路径，路由器依赖路由协议及其确定的路由表完成三层，即网络层的数据转发工作。路由表项中最重要的信息在于目的网段和网关，即下一跳IP地址的对应关系，网关通常是专门的网关服务器或者路由器，而网关会负责将该数据包最终转发至目的网段。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><hr><p>[1] <a href="http://dengqi.blog.51cto.com/5685776/1223132" target="_blank" rel="external">详解网络传输中的三张表，MAC地址表、ARP缓存表以及路由表</a><br>[2] <a href="http://blog.csdn.net/wangerge/article/details/3931491" target="_blank" rel="external">单播、多播(组播)和广播的区别</a><br>[3] <a href="http://blog.csdn.net/zyboy2000/article/details/50528253" target="_blank" rel="external">路由表详解</a><br>[4] <a href="http://www.ywnds.com/?p=1269" target="_blank" rel="external">传输层协议概述</a><br>[5] <a href="http://blog.csdn.net/u014113117/article/details/51311837" target="_blank" rel="external">MAC、IP和路由传输封装过程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;全文概要&quot;&gt;&lt;a href=&quot;#全文概要&quot; class=&quot;headerlink&quot; title=&quot;全文概要&quot;&gt;&lt;/a&gt;全文概要&lt;/h2&gt;&lt;p&gt;计算机网络中一个关键步骤在于通信路径上不同节点对于流经本节点的数据包转发，常见的交换设备主要是交换机(第二层、三层)和路由器(第三层)，在实际运行时，它们各自维护一些表结构帮助完成数据包的正确寻址与转发，本文详细介绍了三张至关重要的表：转发表、ARP表与路由表的在网络数据包转发功能中发挥的作用，以及它们协同工作的原理，顺便也会接着&lt;a href=&quot;http://dongdongdong.me/2017/10/30/Network/Hardware/relay/&quot;&gt;&lt;strong&gt;之前的文章&lt;/strong&gt;&lt;/a&gt;继续谈谈交换机和路由器的一些事儿。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="dongdongdong.me/categories/Network/"/>
    
    
      <category term="Forwarding" scheme="dongdongdong.me/tags/Forwarding/"/>
    
      <category term="Routing" scheme="dongdongdong.me/tags/Routing/"/>
    
      <category term="ARP" scheme="dongdongdong.me/tags/ARP/"/>
    
  </entry>
  
  <entry>
    <title>子网与VLAN</title>
    <link href="dongdongdong.me/2017/11/05/Network/Mechanism/subnet_vlan/"/>
    <id>dongdongdong.me/2017/11/05/Network/Mechanism/subnet_vlan/</id>
    <published>2017-11-05T13:06:06.000Z</published>
    <updated>2017-12-07T07:06:25.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全文概要"><a href="#全文概要" class="headerlink" title="全文概要"></a>全文概要</h2><a id="more"></a><h2 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h2><p>网络/网段与子网的区别</p><p>IP地址与子网掩码作按位与运算结果是网络号</p><p>通过计算机的子网掩码判断两台计算机是否属于同一网段的方法是：</p><blockquote><p>将计算机十进制的IP地址和子网掩码转换为二进制的形式，然后进行二进制按位与计算(全1则得1，不全1则得0)，如果得出的结果是相同的，那么这两台计算机就属于<strong>同一网段</strong>。</p></blockquote><p>通俗来说就是位于同一个局域网内，可以两两ping通，在已知网络IP地址但不知道MAC地址情况下，可以通过广播ARP请求及获取ARP应答的方式构建新ARP表项，在通信发起方处维护对端IP地址到其MAC地址的映射。</p><p>如果属于同一网络区间，这两个地址间的信息交换就不通过<strong>路由器</strong>。如果不属同一网络区间，也就是子网号不同，两个地址的信息交换就要通过<strong>路由器</strong>进行。</p><hr><h3 id="从Ping说起吧"><a href="#从Ping说起吧" class="headerlink" title="从Ping说起吧"></a>从Ping说起吧</h3><p>现有两台服务器A和B，具体配置信息如下表：</p><table><thead><tr><th style="text-align:center">Server ID</th><th style="text-align:center">IP Address</th><th style="text-align:center">Subnet Mask</th><th style="text-align:center">Default Gateway</th><th style="text-align:center">MAC</th></tr></thead><tbody><tr><td style="text-align:center">Server A</td><td style="text-align:center">192.168.26.129</td><td style="text-align:center"><strong>255.255.255.0</strong></td><td style="text-align:center">192.168.26.2</td><td style="text-align:center">08:00:27:28:b9:11</td></tr><tr><td style="text-align:center">Server B</td><td style="text-align:center">192.168.26.3</td><td style="text-align:center"><strong>255.255.255.224</strong></td><td style="text-align:center">192.168.26.2</td><td style="text-align:center">08:00:27:28:b9:22</td></tr></tbody></table><p>默认网关IP：192.168.26.2/24，MAC地址：08:00:27:28:b9:33</p><p>问题描述如下：</p><blockquote><p>B的子网掩码本来应该配成255.255.255.0，但不小心配成了255.255.255.224，那么A与B还能正常通信嘛？</p><ul><li>如果不行，说明原因。</li><li>如果可以，请简述通信流程。</li></ul></blockquote><p>以上是我很欣赏的一本书《Wireshark网络分析就是这么简单》开篇提出的一个面试题，初看问题，心想好歹也是计算机专业学生，大三算是很认真学习过计算机网络这门专业课，且不说研究多么深入，但至少对于基础概念或问题，如OSI分层模型、TCP可靠传输机制、子网划分、路由算法甚至CSMA都如数家珍(毕竟好像教科书上科普重点就这么多…)，小小的一个<strong>ping</strong>得通还是<strong>ping</strong>不通的问题，还能难倒我？</p><p>好吧，我承认，好像真的看蒙了。</p><p>书上给出四个<strong>Plausible</strong>的答案，乍一看，真都好有道理：</p><blockquote><ul><li>版本一<ul><li>答案：“A与B不能通信，因为…这都行的话，子网掩码还有什么用？？？”</li><li>评价：这位的反证法听上去让人无从置疑！</li></ul></li><li>版本二<ul><li>答案：“A与B可以通信，因为它们通过ARP广播获知对方MAC地址。”</li><li>评价：那子网掩码有什么用？上面的反证法刚好可用来反驳这位。</li></ul></li><li>版本三<ul><li>答案：“A与B可以通信，但所有包都要通过默认网关192.168.26.2转发。”</li><li>评价：请问这么复杂的结果你是怎么想到的？</li></ul></li><li>版本四<ul><li>答案：“A与B不能通信，因为ARP不能跨子网。”</li><li>评价：这个答案倒像是过了脑子的。</li></ul></li></ul></blockquote><p>关于以上问题的事实：真相只有一个。</p><p>而事实有时候就很残酷：上面一个都不对。</p><p>解释说明题可与选择题不一样，后者结论对了找准选项就能拿满分，前者即使给出正确结论，但是荒谬无稽的解释则常常给阅卷人想要倒扣分的冲动…好吧，可能我想得比较极端了。</p><p>按照正经答题的顺序，先告诉你正确答案：A与B可以通信。</p><p>接下来看看这个过程中发生了什么，以<strong>B ping A</strong>为例，至于为什么不是<strong>A ping B</strong>，请认真阅读下文内容，在之后我会解释原因。</p><p>要得出这个答案，我在Virtualbox上拿VM搭了个简单网络拓扑，两个VM分别作为Server A和Server B，第三个VM作为默认网关，并设置成允许转发：</p><blockquote><p>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</p></blockquote><p>得到的抓包结果如下图所示：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Network/Mechanism/wireshark-ping-arp.png"><img src="http://oyj8xdeki.bkt.clouddn.com/images/Network/Mechanism/wireshark-ping-icmp.png"><p>那么根据以上Wireshark的抓包结果，按数据包出现顺序，可以将<strong>B ping A</strong>的通信流程作如下分析：</p><ol><li>在B处，计算B的IP地址，即<strong>源IP地址</strong>，与A的IP地址，即<strong>目的IP地址</strong>，分别和B的子网掩码<strong>按位与</strong>的结果，即应用上文介绍的计算网络地址的唯一方法，发现：B对应的网络地址为192.168.26.0，而A对应的网络地址为192.168.26.128，结果不同，因此B会据此判断：本机与目的主机A不在同一网段。而不在同一网段的主机要进行通信，参考前文中关于跨网络通信的机制的内容，了解到B要想与A通信，必须经过<strong>默认网关</strong>(肯定与本机B在同一网段)的转发，故主机B会先把ICMP数据包发往默认网关192.168.26.2，我们知道要发送一个数据包，仅知道目的IP地址是不够的，真正在链路上传输时，目的主机的物理地址即MAC地址也是必须要一同封装在以太网帧中的，然而初始时并不知道默认网关的MAC地址，ARP协议的作用正在于此：B向本网段广播(ff:ff:ff:ff:ff:ff)一个ARP Request包，询问：“谁的IP地址是默认网关的地址，请把你的MAC地址回复给我”——本次通信的<strong>第一个数据包出现</strong>了！</li><li>默认网关接收到此ARP请求后检查目的IP发现就是自己，于是将自己的MAC封装在ARP Reply数据包中回复给主机B，这是<strong>第二个数据包</strong>。</li><li>主机B获知默认网关的MAC地址后，发送一个ICMP数据包给它，<strong>第三个数据包</strong>被发送，其实这个包本意是想发送给主机A，但中间需要默认网关帮忙中转一下，故此ICMP包的目的MAC地址为默认网关的MAC地址，但是目的IP地址仍为主机A的IP地址。至于包是不是被默认网关转发了，还不得而知，除非在默认网关处也抓到个包。</li><li>然后我们在主机B上抓到了<strong>第四个数据包</strong>，居然又是个ARP请求包，根据源MAC地址显示，这个ARP请求来自主机A，那么它想干什么？包内容显示该请求想知道：谁的IP是192.168.26.3，也就是，谁是主机B？<ul><li>在A处重复流程1中的IP地址与网络掩码的<strong>按位与</strong>运算，不过这次的网络掩码要用主机A的掩码，发现：A对应的网络地址为192.168.26.0，而B对应的网络地址竟然也是192.168.26.0！</li><li>你为什么会这么震惊？</li><li>你是不是发现了什么不得了的事儿？</li><li>没错，你已经知道了另一个事实：在A看来，本机与目的主机B在同一网段！从而A要主动向B发包的话，在知道其MAC地址的前提下，是可以直接发送而无需默认网关转发的。但好像又有不对劲的地方…容我反应一下…</li><li>你马上想到一个问题：A为什么会要给B发包？</li><li>我猜你问出这个问题的下一秒，已经知道了答案：当然是因为A已经收到了B的ping包，而A在想要回复B一个ICMP包时候发现自己并不知道主机B的MAC地址呀！</li><li>这间接证明了在流程3中，默认网关确实将B发送给它的那个目的IP地址为A的IP地址的ICMP包，正确地转发给了A。</li></ul></li><li>至于<strong>第五个数据包</strong>，当然是主机B回复主机A的ARP请求的ARP Reply，将自己MAC地址告诉主机A，方便主机A响应此前自己的ping操作。<ul><li>这就又证明了一件事儿：主机B在执行ARP回复时并不考虑子网，这不，虽然ARP请求在它看来，来自另一个子网的IP地址，但也照样回复。</li></ul></li><li>之后，主机B终于收到了来自A的ICMP回包，即在抓到<strong>第六个相关数据包</strong>后，一次ping过程成功完成。</li><li>后来的过程中，主机A、B由于清楚地知道了对方的联系方式(各自以及默认网关的IP地址、MAC地址以及路由信息)，此后的就没必要再发ARP包了，于是此后都是直接抓到双方由于ping产生ICMP数据包。</li></ol><p>分析完这几个包，面试题的答案有了，原来通信流程是这样：B先把ping请求交给默认网关，默认网关再转发给A，而A收到请求后直接把ping回复给B，形成如下所示的三角环路：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Network/Mechanism/triangle-loop.png"><p>让我们再回到之前的那个问题：为什么以<strong>B ping A</strong>为例，而不是<strong>A ping B</strong>呢？</p><p>其实答案已经一目了然：将<strong>B ping A</strong>的结果从第五个数据包到第一个数据包顺序颠倒，再加上之后的第六、七…个数据包，就是<strong>A ping B</strong>的通信流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;全文概要&quot;&gt;&lt;a href=&quot;#全文概要&quot; class=&quot;headerlink&quot; title=&quot;全文概要&quot;&gt;&lt;/a&gt;全文概要&lt;/h2&gt;
    
    </summary>
    
      <category term="Network" scheme="dongdongdong.me/categories/Network/"/>
    
    
      <category term="Subnet" scheme="dongdongdong.me/tags/Subnet/"/>
    
      <category term="VLAN" scheme="dongdongdong.me/tags/VLAN/"/>
    
  </entry>
  
  <entry>
    <title>交换机与路由器详细比较</title>
    <link href="dongdongdong.me/2017/11/05/Network/Hardware/switch_router/"/>
    <id>dongdongdong.me/2017/11/05/Network/Hardware/switch_router/</id>
    <published>2017-11-05T06:15:01.000Z</published>
    <updated>2017-11-27T14:28:33.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全文概要"><a href="#全文概要" class="headerlink" title="全文概要"></a>全文概要</h2><p>作为计算机网络中最重要的两种数据包转发设备，交换机和路由器在功能设计方面既存在本质差别，又包含诸多相似之处，本文从两种设备的工作原理出发，详细介绍了它们之间的种种区别与联系。<br><a id="more"></a></p><h2 id="交换机-Switch"><a href="#交换机-Switch" class="headerlink" title="交换机(Switch)"></a>交换机(Switch)</h2><hr><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><p>交换机的三个核心功能如下：</p><ol><li><strong>学习</strong>：以太网交换机了解与每一端口相连设备的MAC地址，并将地址同相应的端口映射对应起来存放在交换机缓存中的MAC地址转发表中；</li><li><strong>转发</strong>：或称“过滤”，当一个数据帧的目的MAC地址在MAC地址表中有映射条目时，它被转发到连接目的节点的端口而不是所有的端口；若没有对应条目，则转发至交换机除接收端口外的全部端口；</li><li><strong>消除环路</strong>：当检测到出现冗余回路时，以太网交换机通过生成树协议消除回路。</li></ol><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>交换机通过以下步骤完成数据帧转发这一核心功能：</p><ol><li>交换机通过“自学习”过程：根据收到的数据帧中的源MAC地址及其到达端口建立起映射关系，并将其写入转发表中；</li><li>交换机将数据帧中的目的MAC地址同已缓存的转发表条目比较，以决定向哪个端口进行转发并从该端口将数据帧输出至链路；</li><li>如数据帧中的目的MAC地址不在转发表中，则向除其到达端口以外的所有端口转发，这一过程称为泛洪(Flood)；</li><li>广播帧或组播帧则向所有端口转发。</li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>交换机的每一个端口所连接的网段都是一个独立的冲突域，即交换机隔离冲突域；</li><li>交换机所连接的设备仍然在同一个广播域内，也就是说，交换机不能隔离广播域(VLAN环境中除外)；</li><li>交换机依据帧头信息进行转发，因此说交换机是工作在数据链路层的网络设备，此处交换机仅指传统的二层交换设备。后文还会介绍工作在三层甚至四层的交换机。</li></ol><h3 id="转发模式"><a href="#转发模式" class="headerlink" title="转发模式"></a>转发模式</h3><p>交换机有两种转发方式：</p><h4 id="直通转发-Cut-Through"><a href="#直通转发-Cut-Through" class="headerlink" title="直通转发(Cut-Through)"></a>直通转发(Cut-Through)</h4><p>交换机一旦解析到数据包的目的MAC地址，就开始查询MAC地址转发表，向目的端口转发该数据包。往往，交换机在接收到数据包的前6个字节时，实际已经知道目的地址，从而可以决定向哪个端口转发该数据包。直通转发技术的优点是转发速率快、减少延时与提升整体吞吐率。其缺点是交换机在没有完全接收并检查数据包的正确性之前就开始了数据转发，这实际上会给整个交换网络带来许多垃圾通讯包，交换机会被误解为发生了广播风暴。</p><p>因此，直通转发技术适用于网络链路质量较好、出错数据包较少的网络环境。</p><h4 id="存储转发-Store-and-Forward"><a href="#存储转发-Store-and-Forward" class="headerlink" title="存储转发(Store-and-Forward)"></a>存储转发(Store-and-Forward)</h4><p>存储转发技术要求交换机在接收到全部数据包后再决定如何转发，这样一来，由于在转发之前已经收到了数据帧的全部字段内容，当然也收到了最后一个字段FCS(Frame Check Sequence，帧校验序列)，因此，交换机可以在转发之前通过重新计算FSC与接收到的FCS比较从而检查数据包的完整性和正确性。存储转发技术的优点是没有残缺数据包转发，减少了潜在的不必要数据转发。其缺点是由于引入了校验逻辑，增加了额外的时间开销，因而转发速率比直通转发技术要慢。</p><p>因此，存储转发技术适用于普通链路质量的网络环境。</p><h3 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h3><p>三层交换机就是具有部分路由器功能的交换机，三层交换机的最重要目的是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到<strong>一次路由，多次转发</strong>。对于数据包转发等规律性的过程由<strong>硬件</strong>高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由<strong>软件</strong>实现。</p><p><strong>三层交换技术 = 二层交换技术+三层转发技术</strong>：传统交换技术是在OSI网络模型第二层，即数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发，既可实现网络路由功能，又可根据不同网络状况做到最优网络性能。</p><p>三层交换技术实际就是将路由技术与交换技术合二为一的技术，在对第一个数据流进行路由后，它将会产生一个MAC地址与IP地址的映射表，当同样的数据流再次通过时，将根据此表直接从二层通过而不是再次路由，从而消除了由网络层进行路由选择而造成的转发延迟，提高了数据包的转发效率。</p><p>举例说明如下：</p><blockquote><p>假设两个使用IP协议的站点A、B通过第三层交换机进行通信。发送站点A在开始发送时，把自己的IP地址与B站的IP地址比较，利用子网掩码判断B站是否与自己在同一子网内。</p><p>若两个站点在同一子网内，则进行二层的转发，如一开始转发数据所需的目的MAC地址，A站就发送一个ARP广播请求，B站接收到后会将其MAC地址封装在ARP应答中发送给A，A利用此目的MAC地址封装数据包并发送给交换机，交换机此时启用二层交换模块，查找MAC地址转发表，将数据包转发至对应端口并最终发送给站点B；</p><p>若两个站点不在同一子网，那么A想要实现与B的通讯，在ARP缓存表中没有对应的MAC地址条目，就将第一个数据包发送给一个缺省网关，该网关一般在操作系统中已设定好，实际就是三层交换机的第三层交换模块。然后数据包被发送给缺省网关，目的MAC地址就是缺省网关与A相连的端口的MAC地址。三层交换机接收到此数据包，查询路由表以确定到达B的路由(下一跳IP地址和输出端口)，发现主机B在与其端口直连的网段内，于是三层交换机重新封装该数据包，构造一个新的帧头，其中以交换机的输出端口MAC地址为源MAC地址，查询ARP表以获得主机B的MAC地址，以此作为目的MAC地址。通过一定的识别触发机制，确立主机A与B的MAC地址及转发端口的对应关系，实际就是交换机的二层交换模块的“自学习”功能，并记录到转发表，此后从A与B的数据包通信，就直接交由二层交换模块完成转发，这就是所说的一次路由多次转发。</p></blockquote><p>由于仅仅在路由过程中才需要三层处理，绝大部分数据都通过二层交换转发，因此三层交换机的速度很快，接近二层交换机的速度，同时比相同路由器的价格低很多。</p><p>在实际应用过程中，典型的做法是：处于同一个局域网中的各个子网的互联以及局域网中VLAN间的路由，用三层交换机来代替路由器，而只有局域网与公网互联之间要实现跨地域的网络访问时，才通过专业路由器。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>传统交换机通常指工作在数据链路层的交换设备，采用“自学习”方式维护与MAC地址与其输出端口的映射关系，并在数据链路层根据数据帧的目的MAC地址完成其转发功能。二层交换机一般都有专门用于处理数据包转发的ASIC(Application Specific Integrated Circuit，特定用途集成电路)，因此转发速度可以做到非常快，不同厂家采用的ASIC不同，直接影响产品性能。</p><p>三层交换，也称多层交换技术，或IP交换技术，是相对于传统交换概念而提出的：传统的交换技术是在OSI网络标准模型中的第二层，即数据链路层进行操作的，而三层交换技术是在网络模型中的第三层，即网络层实现了数据包的高速转发。简单地说，三层交换技术就是：二层交换技术＋三层转发技术。三层交换技术的出现，解决了局域网中网段划分之后，网段中子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。</p><h2 id="路由器-Router"><a href="#路由器-Router" class="headerlink" title="路由器(Router)"></a>路由器(Router)</h2><hr><h3 id="核心功能-1"><a href="#核心功能-1" class="headerlink" title="核心功能"></a>核心功能</h3><p>一般而言，路由器工作在网络层，其工作模式与二层交换类似，但路由器工作在第三层，这个区别决定了路由器与交换机在转发数据包时使用的控制信息(首部字段)是不同的。</p><p>路由器内部有一个路由表，这表标明了如果要去某个地方，下一步应该往哪走。路由器从某个端口收到一个数据包，它首先把链路层的包头去掉(拆包)，读取目的IP地址，然后查找路由表，若能确定下一步往哪送，则再加上链路层的包头(打包)，把该数据包转发出去；如果不能确定下一步的地址，则向源地址返回一个信息(Unreachable，目的地不可达)，并把这个数据包丢弃。</p><h3 id="工作流-1"><a href="#工作流-1" class="headerlink" title="工作流"></a>工作流</h3><p>路由器接收到数据包后，首先在其自身维护的路由表中查找它的目的地址，若找到了目的地址对应项即获知转发的下一跳地址，就在数据包的MAC首部中添加该IP地址对应的MAC地址作为目的MAC地址，同时IP首部中的TTL(Time to Live)字段也开始减数，并重新计算校验和，最终在其输出端口完成数据帧的重新封装，源MAC地址为输出端口的MAC地址。</p><p>路由器在工作时会运行某种路由通信协议生成路由表，用于生成并维护在数据包到来时查找匹配目的IP地址的表项。如果到某个特定节点有一条以上的路径，则基于预先确定的路由准则是选择最优(代价最小)的传输路径。由于各网段及其相互链接的情况可能会因环境变化而变化，因此路由信息一般也按所使用的路由通信协议的规定根据实时网络拓扑情况而即时更新。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>路由技术其实是由两项最基本的活动组成，即<strong>决定最优路径</strong>和<strong>传输数据包</strong>。其中，数据包的传输相对较为简单和直接，而路由的确定则更加复杂一些。路由算法在路由表中写入各种不同的信息，路由器会根据数据包所要到达的目的地选择最佳路径把数据包发送到可以到达该目的地的下一台路由器处。当下一台路由器接收到该数据包时，也会查看其目标地址，并使用合适的路径继续传送给后面的路由器。依次类推，直到数据包到达最终目的地。 </p><h2 id="冲突域-VS-广播域"><a href="#冲突域-VS-广播域" class="headerlink" title="冲突域 VS 广播域"></a>冲突域 VS 广播域</h2><hr><h3 id="冲突域-Collision-Domain"><a href="#冲突域-Collision-Domain" class="headerlink" title="冲突域(Collision Domain)"></a>冲突域(Collision Domain)</h3><p>以太网使用CSMA/CD(Carrier Sense Multiple Access with Collision Detection，带碰撞检测的载波多路侦听)算法来进行通信介质的访问控制。如果两个或者更多站点同时检测到信道空闲而有帧准备发送，它们将发生冲突，一组竞争信道访问的站点称为冲突域。</p><p>简单来说，在以太网中，如果某个CSMA/CD网络上的任意两个节点在同时通信，即发送数据时会发送冲突，它们几乎同时检测到冲突且只好都放弃传输，那么这个CSMA/CD网络内的全部节点就构成了一个冲突域。如果以太网中的各个网段内部都是以集线器连接，因为集线器会把接收到的帧转发至自身的全部端口，还是会引起冲突，所以即使包含集线器，该网段仍然是一个冲突域。</p><p>显然，同一个冲突域中的节点竞争信道，就会导致冲突和退避。而不同冲突域的节点不会竞争公共信道，则不会发生冲突。在交换式局域网中，每个交换机端口就对应一个冲突域，端口就是冲突域终点。由于交换机具有交换功能，在不同端口之间都有专门的信道，故不同端口的节点之间不会产生冲突。如果每个端口只连接一个节点，那么在任何一对节点之间都不会发生冲突。若一个端口连接到一个共享式局域网(内部多台计算机相连，或直连，或与集线器相连等等方式构成局域网)，那么在与该端口直连局域网中的任意节点之间都会产生冲突，但与该端口直连的节点和与交换机其它端口相连的节点之间通信则不会发生冲突，这样交换机就隔离了不同的冲突域，使得冲突只发生在各个冲突域内部，而不会影响其它冲突域。</p><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>集线器是一种物理层设备，本身不能识别MAC地址和IP地址，当集线器连接的主机设备之间传输数据时，数据包是以广播方式进行传播，即集线器会将收到的数据包广播至其所有端口，而由每台主机根据数据包与自身MAC地址是否匹配来决定是否接收。</p><p>这种情况下，同一时刻由集线器连接的网络中只能有一个节点在占用信道传输数据，即所谓的”Top Talker“，其它节点在检测到信道忙碌则退避等待，若信道空闲时同时有两个或多个节点开始传输，则会发生冲突，各自放弃数据传输。集线器所有端口共享集线器的整个带宽，即所有端口为一个冲突域，如下图所示：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Hardware/collision-domain-hub.png"><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>交换机工作在数据链路层，在接收数据帧后，通过查找自身维护的MAC地址转发表找出对应输出端口，并把数据传送到目的端口。</p><p>交换机在同一时刻可进行多个端口之间的数据传输，即支持“并发传输”，这是由于交换机不同端口之间都有专门的链路相连，且独享全部带宽。每一端口相连的都是独立的物理网段，连接在端口上的网络设备独自享有全部带宽，因此，交换机起到了分割不同冲突域的作用，每一个端口相连的网段为一个独立的冲突域，如下图所示：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Hardware/collision-domain-switch.png"><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>集线器是一个标准的共享式设备，也就是同一时刻只有一个端口下联的设备可以发送数据。正常工作时，集线器随机选出某一端口设备并让它独占全部带宽与集线器上联设备(如交换机、路由器等)进行通信。因此，集线器设备的所有端口即形成了一个冲突域。</p><p>为了有效避免冲突，局域网中使用交换机(Switch)来分割冲突域。对网络进行分割的原因是为了分离流量并创建更小的冲突域来使用户获得更高的带宽，否则同一时刻数据太多容易导致网络拥挤形成阻塞。</p><h3 id="广播域-Broadcast-Domain"><a href="#广播域-Broadcast-Domain" class="headerlink" title="广播域(Broadcast Domain)"></a>广播域(Broadcast Domain)</h3><p>常见广播情形有如下两种：</p><ol><li>源节点发送数据帧给全部主机，在封装数据帧时直接将广播地址:ff:ff:ff:ff:ff:ff作为目的MAC地址，则交换机在接收该帧时解析到该广播地址，就会复制数据帧并向全部非接收端口转发；</li><li>当转发表中没有匹配的目的MAC地址项时，交换机会将数据帧复制并转发至全部非接收端口，这一过程实际也是广播。</li></ol><h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>然而，以上两种形式的广播会到什么地方结束呢？答案是路由器。<br>为什么到路由器就结束了呢？再来回顾一下路由器的工作流程：</p><p>当路由器接收到一个数据包时，首先提取数据包头的目的MAC信息，与自身MAC表比较，分两种情况：</p><ol><li>如果找到对应项，则按MAC表进行转发(与交换机一样)；</li><li>如果没找到则提取数据包头的目的IP地址，与自身路由表进行比较，这里又分两种情况：<br> (1) 存在对应的路由表项，则按路由表转发(与查到MAC表很像)；<br> (2) 没找到对应路由表项，则按缺省路由转发至默认网关(自始自终没有出现过广播！)。</li></ol><p>路由表和MAC的区别在于，路由表存放的是目的IP，即下一步要去地方的IP地址。</p><p>广播在路由器能够结束，原因就在于路由器会在查找不到对应MAC表时，根据目的IP进行路由。路由过程的两种情况都不存在广播。因此，路由器可以隔离广播域，如下图所示：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Hardware/broadcast-domain-router.png"><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>以太网中，冲突域通常是由集线器组织的，与同一个集线器相连的全部节点就组成了一个冲突域。交换机的每个端口相连的网络都是一个单独的冲突域。</p><p>广播域是指一个节点发出一个广播信号后，能够接收到该信号的全部节点的集合。通常来说一个局域网就是一个广播域。交换机的所有端口都在同一个广播域内。</p><ul><li><strong>冲突域</strong>：在同一个冲突域中的每一个节点都能收到它们之中任意一个节点发送的帧；</li><li><strong>广播域</strong>：网络中能接收到任意节点发出的广播帧的所有节点的集合。</li></ul><p>冲突域是基于第一层，即物理层的；广播域是基于第二层，即数据链路层的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二层交换机工作在数据链路层，路由器工作在网络层，而三层交换机则工作在数据链路层和网络层。</p><h3 id="二层交换机-VS-三层交换机"><a href="#二层交换机-VS-三层交换机" class="headerlink" title="二层交换机 VS 三层交换机"></a>二层交换机 VS 三层交换机</h3><p>三层交换机使用了三层交换技术，简单地说，三层交换技术就是：二层交换技术＋三层转发技术。即三层交换机在包含了全部二层交换机的功能之外，还具备一部分的网络层功能。它解决了局域网中网段划分之后，网段中子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。</p><h3 id="二层交换机-VS-路由器"><a href="#二层交换机-VS-路由器" class="headerlink" title="二层交换机 VS 路由器"></a>二层交换机 VS 路由器</h3><p>二层交换机即传统交换机，从网桥发展而来，属于OSI第二层即数据链路层设备。它根据MAC地址寻址，转发表(目的MAC地址到输出端口的映射)的建立和维护由交换机自动进行。</p><p>路由器属于OSI第三层即网络层设备，它根据IP地址进行寻址，通过运行路由协议生成和维护路由表(目的IP地址到输出端口、下一跳IP地址的映射)。</p><p>交换机最大的好处是快速，由于交换机只须识别以太网帧首部中的MAC地址，直接根据MAC地址产生选择转发端口，算法简单，便于ASIC实现，因此转发速度极高。但与此同时，交换机的工作机制也带来一些问题：</p><ol><li><p><strong>回路</strong>：根据交换机地址学习和转发表建立算法，交换机之间不允许存在回路。一旦存在回路，必须启动生成树算法，阻塞掉产生回路的端口。而路由器的路由协议没有这个问题，路由器之间可以有多条通路来平衡负载，提高可靠性；</p></li><li><p><strong>负载集中</strong>：交换机之间只能有一条通路，使得信息集中在一条通信链路上，不能进行动态分配，以平衡负载。而路由器的路由协议算法可以避免这一点，OSPF路由协议算法不但能产生多条路由，而且能为不同的网络应用选择各自不同的最佳路由；</p></li><li><p><strong>广播控制</strong>：交换机只能缩小冲突域，而不能缩小广播域。整个交换式网络就是一个大的广播域，广播报文散布到整个交换式网络。而路由器可以隔离广播域，广播报文不能通过路由器继续进行广播；</p></li><li><p><strong>子网划分</strong>：交换机只能识别MAC地址。MAC地址是物理地址，而且采用<strong>平坦</strong>的地址结构，因此不能根据MAC地址来划分子网。而路由器识别IP地址，IP地址由网络管理员分配，是逻辑地址且IP地址具有<strong>层次</strong>结构，被划分成网络号和主机号，可以非常方便地用于划分子网，路由器的主要功能就是用于连接不同的网络，甚至是异构网络；</p></li><li><p><strong>保密问题</strong>：虽说交换机也可以根据帧的源MAC地址、目的MAC地址和其他帧中内容对帧实施过滤，但路由器根据报文的源IP地址、目的IP地址、TCP端口地址等内容对报文实施过滤，更加直观方便；</p></li><li><p><strong>介质相关</strong>：交换机作为桥接设备也能完成不同链路层和物理层之间的转换，但这种转换过程比较复杂，不适合ASIC实现，势必降低交换机的转发速度。因此目前交换机主要完成相同或相似物理介质和链路协议的网络互连，而不会用来在物理介质和链路层协议相差甚远的网络之间进行互连。而路由器则不同，它主要用于不同网络之间互连，因此能连接不同物理介质、链路层协议和网络层协议的网络。路由器在功能上虽然占据了优势，但价格昂贵，报文转发速度低。近几年，交换机为提高性能做了许多改进，其中最突出的改进是虚拟网络和三层交换。</p></li></ol><p>路由器可以划分子网，从而缩小广播域，减少广播风暴对网络的影响。路由器每一端口连接一个子网，广播报文不能经过路由器广播出去，连接在路由器不同端口的子网属于不同子网，子网范围由路由器物理划分。</p><p>对交换机而言，每一个端口对应一个网段，而子网由若干网段构成，通过对交换机端口的组合，可以逻辑划分子网。广播报文只能在子网内广播，不能扩散到别的子网内，因此可通过合理划分逻辑子网，达到控制广播的目的。由于逻辑子网由交换机端口任意组合，没有物理上的相关性，因此称为虚拟子网，或叫虚拟网(VLAN)。虚拟网技术不用路由器就解决了广播报文的隔离问题，且虚拟网内网段与其物理位置无关，即相邻网段可以属于不同虚拟网，而相隔甚远的两个网段可能属于不同虚拟网，也可能属于同一个虚拟网。不同虚拟网内的终端之间不能相互通信，增强了对网络内数据的访问控制。</p><h3 id="三层交换机-VS-路由器"><a href="#三层交换机-VS-路由器" class="headerlink" title="三层交换机 VS 路由器"></a>三层交换机 VS 路由器</h3><p>在第三层交换技术出现之前，几乎没有必要将路由功能器件和路由器区别开来，他们完全是相同的：提供路由功能并由路由器负责执行。然而，现在第三层交换机完全能够执行传统路由器的大多数功能。作为一种可跨层次工作的网络互连设备，第三层交换机具有以下特征：</p><ol><li>转发基于第三层地址的业务流；</li><li>完全交换功能；</li><li>可以完成特殊服务，如报文过滤或认证；</li><li>执行或不执行路由处理。</li></ol><p>第三层交换机与传统路由器相比有如下优点：</p><ol><li>子网间传输带宽可任意分配：传统路由器每个接口连接一个子网，子网通过路由器进行传输的速率被接口的带宽所限制。而三层交换机则不同，它可以把多个端口定义成一个虚拟网，把多个端口组成的虚拟网作为虚拟网接口，该虚拟网内信息可通过组成虚拟网的端口送给三层交换机，由于端口数可任意指定，子网间传输带宽没有限制。</li><li>合理配置信息资源：由于访问子网内资源速率和访问全局网中资源速率没有区别，子网设置单独服务器的意义不大，通过在全局网中设置服务器群不仅节省费用，更可以合理配置信息资源。</li><li>降低成本：通常的网络设计用交换机构成子网，用路由器进行子网间互连。目前采用三层交换机进行网络设计，既可以进行任意虚拟子网划分，又可以通过交换机三层路由功能完成子网间通信，为此节省了使用路由器带来的高昂成本。</li><li>交换机之间连接灵活：作为交换机，它们之间不允许存在回路，作为路由器，又可有多条通路来提高可靠性、平衡负载。三层交换机用生成树算法阻塞造成回路的端口，但进行路由选择时，依然把阻塞掉的通路作为可选路径参与路由选择。</li></ol><p>交换机和路由器是性能和功能的矛盾体，交换机交换速度快，但控制功能弱，路由器控制性能强，但报文转发速度慢。解决这个矛盾的最新技术是三层交换，既有交换机线速转发报文能力，又有路由器良好的控制功能。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><hr><p>[1] <a href="http://blog.sina.com.cn/s/blog_5e1a889d0101370d.html" target="_blank" rel="external">交换机的工作原理</a><br>[2] <a href="http://blog.csdn.net/shmily_cml0603/article/details/9334795" target="_blank" rel="external">二、三层交换机和路由器的工作原理与主要区别</a><br>[3] <a href="http://www.net130.com/ccnp/20040229009.htm" target="_blank" rel="external">三层交换机与路由器的比较</a><br>[4] <a href="http://blog.smallmuou.xyz/network/2017/04/14/%E6%95%99%E4%BD%A0%E8%AF%BB%E6%87%82%E8%B7%AF%E7%94%B1%E8%A1%A8.html" target="_blank" rel="external">教你读懂路由表</a><br>[5] <a href="http://net.zhiding.cn/network_security_zone/2008/0514/860886.shtml" target="_blank" rel="external">网络知识：二层、三层、四层交换机的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;全文概要&quot;&gt;&lt;a href=&quot;#全文概要&quot; class=&quot;headerlink&quot; title=&quot;全文概要&quot;&gt;&lt;/a&gt;全文概要&lt;/h2&gt;&lt;p&gt;作为计算机网络中最重要的两种数据包转发设备，交换机和路由器在功能设计方面既存在本质差别，又包含诸多相似之处，本文从两种设备的工作原理出发，详细介绍了它们之间的种种区别与联系。&lt;br&gt;
    
    </summary>
    
      <category term="Network" scheme="dongdongdong.me/categories/Network/"/>
    
    
      <category term="Switch" scheme="dongdongdong.me/tags/Switch/"/>
    
      <category term="Router" scheme="dongdongdong.me/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>Git工作区、版本库与暂存区</title>
    <link href="dongdongdong.me/2017/10/31/Git/working-directory_repository_stage/"/>
    <id>dongdongdong.me/2017/10/31/Git/working-directory_repository_stage/</id>
    <published>2017-10-31T13:40:12.000Z</published>
    <updated>2017-11-27T14:28:33.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全文概要"><a href="#全文概要" class="headerlink" title="全文概要"></a>全文概要</h2><p>Git与其它版本控制系统如SVN的一个最大的不同之处就是发明了暂存区的概念，本文从创建Git版本库开始，依次描述了追踪文件、修改文件、丢弃修改、提交修改等基本Git操作，在此过程中介绍了Git版本控制系统中三个重要概念：工作区、版本库与暂存区。</p><a id="more"></a><h2 id="工作区-Working-Directory"><a href="#工作区-Working-Directory" class="headerlink" title="工作区(Working Directory)"></a>工作区(Working Directory)</h2><hr><p>就是你能在电脑中看到的目录，即本地目录，比如我的<strong>GitTest</strong>就是一个工作区，准确的来说，Git工作区应该指的是执行过git init初始化后的本地目录，下图可以看到现在工作区内只有一个文件:a.txt：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/0-git-init.png"><h2 id="版本库-Repository"><a href="#版本库-Repository" class="headerlink" title="版本库(Repository)"></a>版本库(Repository)</h2><hr><p>工作区有一个隐藏目录<strong>.git</strong>，这个不是工作区，而是Git的版本库。</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/repository.png"><p>Git版本库里存了很多东西，其中最重要的就是称为”Stage”的暂存区，还有Git为我们自动创建的第一个本地分支Master。</p><p>分支与HEAD的概念之后的博文会详细讲解。</p><h2 id="暂存区-Stage"><a href="#暂存区-Stage" class="headerlink" title="暂存区(Stage)"></a>暂存区(Stage)</h2><hr><p>前面说到暂存区实际是Git版本库里面的一个区域，具体的结构参见下图：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/working-directory_repository_stage.png"><p>下文中会结合一次完整的版本控制操作过程来具体讲解各个区域的作用。</p><h2 id="本地版本控制流程实例"><a href="#本地版本控制流程实例" class="headerlink" title="本地版本控制流程实例"></a>本地版本控制流程实例</h2><hr><p>实例开始之前在强调一下，使用git命令时，status绝对是一个功能超乎想象重要的参数，让使用者可以获得整个版本文件的实时视图。</p><p>流程按照上图中显示的git版本库继续操作，所有操作均在本地分支Master上完成：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/1-untracked-file.png"><p>工作区中包含未被追踪的文件(Untracked files)：<strong>a.txt</strong>，按提示使用命令：<strong>git add &lt;文件名&gt;</strong>，就可以将该文件添加至<strong>暂存区</strong>，并使用命令<strong>git status</strong>，查看当前版本完整视图：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/2-git-add.png"><p>根据提示使用命令：<strong>git rm - -cached &lt;文件名&gt;</strong>，可取消缓存在暂存区的文件修改：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/3-git-rm-cached.png"><p>发现暂存区的文件被弹出，<strong>a.txt</strong>重新回到了<strong>Untracked files</strong>下，再次执行<strong>git add</strong>将其加入暂存区：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/4-git-add-again.png"><p>接下来使用命令：<strong>git commit -m “message”</strong>，将暂存区文件提交，此时终端显示“nothing to commit, working directory clean”(没有可提交的内容，工作区是干净的)，这是因为工作区中的文件修改已全部提交至版本库中的本地分支Master上，工作区与Master分支内容完全一致，即没有“脏”内容(类比数据库的“脏读”(Dirty Read)，脏读是指一个事务读到了另一个事务还未提交的数据，实际就是存在有未提交的数据)的情况：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/5-git-commit.png"><p>下面我们试着在工作区创建一个新文件<strong>b.txt</strong>，此时显然该文件属于<strong>Untracked files</strong>：</p><pre><code>b.txt这是第一次修改.</code></pre><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/6-git-touch-new-file.png"><p>同样将其添加到暂存区中：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/7-git-add.png"><p>如果你足够细心，不难发现一些<strong>有意思的事情</strong>：同样是追踪文件即将文件修改加入暂存区，两次执行<strong>git add</strong>命令的效果一样，但是Git给出的取消文件暂存命令提示不太一样：</p><ul><li><p>将<strong>a.txt</strong>加入暂存区时，Git提示取消暂存的命令为：<strong>git rm - -cached &lt;文件名&gt;</strong>。</p></li><li><p>将<strong>b.txt</strong>加入暂存区时，Git提示取消暂存的命令为：<strong>git reset HEAD &lt;文件名&gt;</strong>。</p></li></ul><p>出现这种差异是因为<strong>a.txt</strong>属于第一次提交(Initial Commit)的文件内容，对应取消暂存的命令就是：<strong>git rm - -cached &lt;文件名&gt;</strong>。而如果在初始化版本库(即<strong>git init</strong>)之后新增的文件，取消暂存的命令则是：<strong>git reset HEAD &lt;文件名&gt;</strong>。</p><p>那我们执行取消暂存<strong>b.txt</strong>的命令：<strong>git reset HEAD b.txt</strong>，发现<strong>b.txt</strong>重新回到<strong>Untracked files</strong>类别下：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/8-git-reset-HEAD-unstage.png"><p>再次将<strong>b.txt</strong>添加到暂存区：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/9-git-add.png"><p>然后我们在最后提交之前再对<strong>b.txt</strong>进行修改，增加一行内容：</p><pre><code>b.txt这是第一次修改.这是第二次修改.</code></pre><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/10-git-modify.png"><p>发现<strong>b.txt</strong>同时在暂存区(Changes to be committed)和未暂存区(Changes not staged for commit，为了与暂存区对比，姑且这么称呼，实际上就是工作区，只不过对应文件在上一次被暂存后又再次被修改过，而修改过的文件内容还未被暂存)，但是描述有些许不同：</p><ul><li><p>在暂存区中，<strong>b.txt</strong>前面修饰词为<strong>new</strong>，表示对于暂存区而言，这是<strong>b.txt</strong>第一次被加入到暂存区中。</p></li><li><p>在未暂存区中，<strong>b.txt</strong>前面修饰词为<strong>modified</strong>，表示对于为暂存区而言，它已经知道<strong>b.txt</strong>之前已经被暂存过一次，而在那之后又被修改过。</p></li></ul><p>对于状态下的<strong>b.txt</strong>文件，Git都给出了明确的提示，我们挨个尝试一遍。</p><p>直接取消上一次暂存：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/11-git-reset-HEAD-unstage.png"><p>再次暂存<strong>b.txt</strong>：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/12-git-add.png"><p>再次修改<strong>b.txt</strong>，增加一个文本行：</p><pre><code>b.txt这是第一次修改.这是第二次修改.这是第三次修改.</code></pre><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/13-git-modify.png"><p>执行命令：<strong>git checkout - - &lt;文件名&gt;</strong>，该命令效果应该是丢弃本地修改：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/14-git-checkout-discard-changes.png"><p><strong>cat</strong>命令查看<strong>b.txt</strong>内容发现上次对<strong>b.txt</strong>的修改(新增一个文本行)果然被丢弃。</p><p>再次修改<strong>b.txt</strong>内容，增加一个空行和一个文本行：</p><pre><code>b.txt这是第一次修改.这是第二次修改.这是第四次修改.</code></pre><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/15-git-modify.png"><p>这一次我们直接将修改后的<strong>b.txt</strong>添加至暂存区：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/16-git-add.png"><p>提交暂存区到本地分支Master：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/Git/working-directory_repository_stage/17-git-commit.png"><p>以上，我们就完成了一次本地分支的版本控制。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><ol><li><strong>工作区</strong>：本地目录，包含所有被Git追踪的文件的实时内容；</li><li><strong>版本库</strong>：工作区中的.git文件夹，实际包含暂存区和当前分支指针HEAD，通过命令：<strong>git init</strong>可以初始化创建版本库；</li><li><strong>暂存区</strong>：暂存被追踪的文件修改，为正式提交到本地分支提供内容。</li></ol><ul><li><strong>工作区</strong>文件修改后通过命令：<strong>git add &lt;文件名&gt;</strong>，将文件添加至<strong>暂存区</strong>。</li><li><strong>暂存区</strong>通过命令：<strong>git rm –cached &lt;文件名&gt;</strong>(针对在初始化版本库之前就已经在<strong>工作区</strong>中的文件)，或<strong>git reset HEAD &lt;文件名&gt;</strong>(针对在初始化版本库之后才新增的文件)，将暂存文件弹回到<strong>工作区</strong>。</li><li>若要在<strong>工作区</strong>丢弃文件自上一次暂存以来的全部修改，可执行命令：<strong>git checkout – &lt;文件名&gt;</strong>。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><hr><p>[1] <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="external">廖雪峰Git教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;全文概要&quot;&gt;&lt;a href=&quot;#全文概要&quot; class=&quot;headerlink&quot; title=&quot;全文概要&quot;&gt;&lt;/a&gt;全文概要&lt;/h2&gt;&lt;p&gt;Git与其它版本控制系统如SVN的一个最大的不同之处就是发明了暂存区的概念，本文从创建Git版本库开始，依次描述了追踪文件、修改文件、丢弃修改、提交修改等基本Git操作，在此过程中介绍了Git版本控制系统中三个重要概念：工作区、版本库与暂存区。&lt;/p&gt;
    
    </summary>
    
      <category term="Version Control" scheme="dongdongdong.me/categories/Version-Control/"/>
    
    
      <category term="Git" scheme="dongdongdong.me/tags/Git/"/>
    
      <category term="Working Directory" scheme="dongdongdong.me/tags/Working-Directory/"/>
    
      <category term="Repository" scheme="dongdongdong.me/tags/Repository/"/>
    
      <category term="Stage" scheme="dongdongdong.me/tags/Stage/"/>
    
  </entry>
  
  <entry>
    <title>网络互连设备小结</title>
    <link href="dongdongdong.me/2017/10/30/Network/Hardware/relay/"/>
    <id>dongdongdong.me/2017/10/30/Network/Hardware/relay/</id>
    <published>2017-10-30T07:18:30.000Z</published>
    <updated>2017-11-27T14:28:33.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全文概要"><a href="#全文概要" class="headerlink" title="全文概要"></a>全文概要</h2><p>计算机网络往往由多种不同类型的网络通过特殊的设备相互连接而成，本文简要介绍了转发器、集线器、网桥、桥接器、交换机、路由器等多种网络互连设备的功能原理。</p><a id="more"></a><h2 id="网络互连设备"><a href="#网络互连设备" class="headerlink" title="网络互连设备"></a>网络互连设备</h2><hr><p>计算机网络往往由多种不同类型的网络互连(Interconnect)连接而成。如果几个计算机网络只是物理上连接在一起，它们之间并不能进行通信，那么这种形式上的“互连”毫无意义。因此在描述这些网络“互连”的同时，实际暗示这些相互连接的计算机是可以以某种方式进行通信的，由约定共同遵守的网络协议决定通信的方式和细节。换句话说，从逻辑和功能上来讲，这些计算机已经组成了一个大型的计算机网络，或称为“互联网络”(internet，注意首字母小写，Internet已经用来形容全球范围内最大的互联网络)。</p><p>将网络互相连接起来要使用一些中间设备(中间系统)，ISO中术语称之为“中继”(Relay)系统，根据中继系统所在的层次，大致由如下五种中继系统：</p><ul><li>物理层(第一层)中继系统，即<strong>转发器(Repeater)</strong></li><li>数据链路层(第二层)中继系统，即<strong>网桥</strong>或<strong>桥接器(Bridge)</strong></li><li>网络层(第三层)中继系统，即<strong>路由器(Router)</strong></li><li>网桥和路由器混合物：<strong>桥路器(Brouter)</strong>，兼有网桥和路由器的功能</li><li>网络层以上的中继系统，即<strong>网关(Gateway)</strong></li></ul><p>当中继系统是转发器时，一般不称之为“网络互连”，因为这仅仅是把一个网络从物理上扩展了，本身仍只是一个网络。高层网关由于比较复杂，目前使用较少。因此通常在讨论网络互连时都是指利用交换机和路由器进行互连的网络。下面会简要介绍各种网络互连设备的基本功能和原理。</p><h2 id="转发器"><a href="#转发器" class="headerlink" title="转发器"></a>转发器</h2><hr><p>转发器(Repeater)又被称为中继器、放大器，执行物理层协议，负责第一层即物理层的数据中继。由于电信号在传输过程中会不断衰减，为了不让信号到达通信目的地时强度太小甚至完全消失，必须每传输一段距离就使用中继器放大电信号，使其能够传输到偏远的通信对端。</p><p>转发器用于互连两个相同类型的网段，主要功能是延伸网段和改变传输媒体，从而实现信息位的转发，它本身并不执行信号的过滤功能。</p><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><hr><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>集线器(HUB)是一种典型的特殊的转发器，它的作用简单来说就是将一些机器连接起来组成一个局域网。HUB本身是“中心”的意思，多用于建立星型或树型网络拓扑。它不具有智能处理能力，处理的数据只是电流而已，采用共享带宽的工作方式，连接到同一个集线器的所有计算机采用CSMA/CD方式竞争带宽。</p><p>集线器处于纯硬件网络底层设备，基本上不具有类似于交换机的“智能记忆”和“自学习”能力，更不具有交换机维护的MAC地址端口映射表(转发表,Forwarding Table)，所以它发送数据时都是没有目的性的，直接采用广播方式发送。也就是说当它要向某节点发送数据时，不是直接把数据发送到目的节点，而是把数据包发送到所有与集线器物理相连的所有节点，因此它也可以叫做多端口转发器(Multiport Repeater)。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><p>集线器的主要功能就是对接收到的信号进行再生、整形和放大，以扩大网络信号的传输距离，同时把所有节点集中在以它为中心的节点上。它同样工作于物理层，与网卡(网络适配器)、网线等传输介质一样，属于局域网中的基础设备，采用CSMA/CD介质访问控制协议，即具有碰撞检测功能，有碰撞发生则需要避让，一个说完了，另一个人再说，通信效率较低。</p><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>集线器的这种广播数据发送方式很明显有四点不足：</p><ol><li>用户数据包向所有节点发送，数据通信的安全性无法保证；</li><li>由于所有数据包都是向所有节点同时发送，加上其共享带宽的方式，带宽资源浪费严重，容易造成网络拥塞，降低整体网络性能；</li><li>非双工(半双工)传输，任意节点要么只发不收，要么只收不发；</li><li>连接到同一个集线器不同端口的多个主机，任意时刻只能有一个在发送数据，其余会由于检测到碰撞(信道竞争)而阻塞发送。</li></ol><h3 id="应用趋势"><a href="#应用趋势" class="headerlink" title="应用趋势"></a>应用趋势</h3><p>由于集线器会把收到的任何数字信号，经过再生和放大，再向集线器的所有端口提交，这会造成信号之间碰撞的机会很大，而且信号也很有可能被窃听。这还意味着所有连接到该集线器的设备，都是属于同一个碰撞域和广播域，因此大部分集线器现在都已经被交换机所取代。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>集线器工作在物理层，负责局域网内部通信，将其接收到的数据帧广播至全部端口，与其相连的全部网络节点属于同一个冲突域。</p><h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><h3 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h3><p>网桥(Bridge)负责数据链路层的数据中继，互连两个独立的、仅在低两层(物理层和数据链路层)实现上有差异的子网。</p><h3 id="核心功能-1"><a href="#核心功能-1" class="headerlink" title="核心功能"></a>核心功能</h3><p>数据链路层的作用包括：链路建立、维护和拆除、帧封装、帧传输、帧同步、帧错误控制以及流量控制。网桥工作在数据链路层，将两个局域网(LAN)连接起来，根据MAC地址(物理地址)来转发帧，可以看做是一个“低层路由器”(说路由器是三层交换机是一个道理，路由器工作在网络层，根据网络地址即IP地址进行转发)。它可以有效连接两个LAN，将本地通信范围限制在本网段内，并转发相应的信号到另一网段。网桥通常用于连接数量不多的、同一类型的网段。</p><h3 id="隔离冲突域"><a href="#隔离冲突域" class="headerlink" title="隔离冲突域"></a>隔离冲突域</h3><p>多个集线器连接在一起时，由于是广播通信，碰撞几率极大，所以需要一种设备，能够有效隔离子网，即不同网段，让各网段的广播通信仅仅发生在自身内部，网桥正好起到了隔离冲突域的作用。</p><h3 id="存储转发"><a href="#存储转发" class="headerlink" title="存储转发"></a>存储转发</h3><p>网桥能够识别数据链路层中的数据帧，并将这些帧临时存储于自身内存之中，再重新生成信号作为一个全新的数据帧转发给相连的另一个网段，由于网桥可以对数据帧进行拆包、暂存和重新打包(称为“存储转发机制”,Store-and-Forward)，网桥能够连接不同技术参数、传输速率的数据链路。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>网桥的存储和转发功能与中继器相比有优点也有缺点：</p><ul><li><p>优点：使用网桥互连克服了物理限制，这意味着构成LAN的数据站总数和网段数很容易扩充。网桥纳入存储和转发功能可使其适应于连接使用不同MAC协议的两个LAN，从而构成一个不同LAN混连在一起的网络环境。网桥的中继功能仅仅依赖于MAC地址(具有交换机一样的转发机制，通过自学习维护转发表(MAC地址到网桥端口的映射)，根据目的MAC地址查找转发表决定要转发至的端口)，因此对高层协议完全透明。网桥将一个较大的LAN分成段，有利于改善可靠性、可用性和安全性。</p></li><li><p>缺点：由于网桥会在执行转发之前先接收帧并进行缓冲，与中继器相比会引入更多时延。并且网桥不提供流量控制功能，在流量爆发时容易过载，严重时会丢失帧。123</p></li></ul><p>不过，网桥的优点多过于缺点正是其广泛使用的原因。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>网桥工作在数据链路层，负责跨局域网的主机通信，根据其所维护转发表(MAC表)完成转发，隔离冲突域。局域网内部通信不过网桥。</p><p>网桥相当于二层交换机，它可以在数据链路层“桥接”两个网段。它比HUB强一点的在于它分离了两个网段，不会把某网段内部(LAN内部)的数据包广播到另一个网段。因此，两个网段之间不会产生不必要的信号冲突碰撞，例如：AB在桥东，CD在桥西，AB对话时，CD也可以对话；但AC对话时，BD要避让。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><hr><h3 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h3><p>交换机(Switch)是一种简化的网桥，互连相同类型的网络，也工作在数据链路层。它采用独享带宽的工作方式，比集线器更智能，它关注数据包的MAC地址部分：目的地址和源地址，采用一种“自学习”的方式：根据收到的数据帧中的源MAC地址以及其进入交换机的端口两者之间建立映射，并将其写入所维护的一张MAC转发表(Forwarding Table based on MAC)，定期更新或废弃表项。每次新到来一个数据包，交换机抽取其头部中的目的MAC地址，查找转发表对应项，随后将该数据包转发到表项指示的交换机端口。而对于无法在转发表中找到对应项的数据帧，尤其是在交换机刚刚加入网络初期时，交换机便将此帧转发至除其进入端口以外的全部交换机端口。</p><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>特别地，对于转发表项指示将该数据帧发往此帧进入交换机的端口时，表明是源主机想向同一个LAN中的目的主机发包，通常LAN由集线器连接多个主机构成，而一旦其中某个主机想要通信，首先会把数据包发往与其直连的集线器，而集线器会进行全端口转发，这样与该集线器相连的，也就是同一局域网段内的所有主机实际都收到了一份数据包的一份拷贝，所以如果该数据包最终被集线器也广播至交换机处，那么交换机通过查找转发表发现源端口和转发端口是一样的，那么交换机就知道该包之前已在同一网段中广播，也就是说目的主机早就收到了数据包，因此，面对这样的数据包，交换机的处理方法很简单：直接丢弃。</p><h3 id="物理构造"><a href="#物理构造" class="headerlink" title="物理构造"></a>物理构造</h3><p>在交换机内部存有一条背部总线和内部交换矩阵，其中，背部总线用于连接交换机的所有端口，内部交换矩阵用于查找数据包所需传送的目的地址所在端口。控制电路受到数据包后，首先通过内部交换矩阵对其目的端口进行查询，若查询到则立刻将数据包发往该端口，若没有查询到，则广播至所有端口，接受端口发出回应后，将数据包发往该端口，并将其添加至内部交换矩阵中。</p><h3 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h3><p>交换机的转发表(又称为MAC表)是自动地、动态地、自治地建立的，即没有任何来自网络管理员或配置协议的任何干预，因此，通常称交换机创建并维护转发表的过程称为是“自学习”(Self-learning)的，具体步骤如下：</p><ol><li>交换机初始化为空，即没有任何表项； </li><li>对于在某接口接收到的每个入帧，该交换机为其在转发表中存储①帧源地址字段中的源MAC地址②该帧到达的交换机端口③当前时间戳，交换机以这种方式在它的表中记录发送节点所在的LAN字段(与某个交换机端口直接相连)，若在LAN中的每个节点最终都发送了一个帧，则每个节点在转发表中都会被记录下来；</li><li>如果在一段时间，称为“老化期”(Aging Time)之后(此时间由交换机中的一个定时器维护)，交换机都没有接收到以某个表项中的MAC地址作为源地址的帧，那么就删除该表项。</li></ol><p>由于交换机只会将数据包发往转发表中该目的MAC对应的端口，而不是广播至其所有端口，因此，交换机可以用来隔离链路层广播域，即冲突域，每个交换机端口都与一个冲突域相连。但它工作在数据链路层，从而无法处理网络地址，如IP地址，因此无法划分网络层广播域，即广播域。</p><ul><li>冲突域：在同一个冲突域中的每一个节点都能收到任意内部节点发送的任何帧(会通过集线器转发)，即冲突域是一个网段(LAN)，或者说该网段内全部节点的集合；</li><li>广播域：网络中能接收到任意设备发出的广播帧的所有设备的集合。</li></ul><p>看到这里，势必需要把网桥和交换机比较一番：</p><ol><li>从网络数据包的转发层面，两者都是通过建立、维护和查询转发表完成转发工作；</li><li>网桥的端口数较少，通常只有2个，当然也有多端口的网桥设备，交换机则一般拥有多个物理端口；</li><li>交换机工作时，实际上允许许多组端口间的数据转发通道同时工作，相当于多个网桥集成在一个设备中同时完成转发工作，所以交换机的转发能力远强于一般仅有两个端口的网桥；</li><li>由于交换机能够支持多端口，因此可以把网络系统划分为更多的物理网网段，使得整个网络系统具有更高的带宽；</li><li>交换机内部一般使用<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit" target="_blank" rel="external">ASIC(Application Specific Integrated Circuit， 特定用途集成电路)</a>的硬件芯片来实现转发，同时由于是硬件转发，其转发性能非常高，数据传输速率要快于网桥；</li><li>网桥在发送数据帧前，通常要接收到完整的数据帧并执行帧检测序列FCS后，才开始转发该数据帧。交换机具有存储转发和直接转发两种帧转发方式。直接转发方式在发送数据以前，不需要在接收完整个数据帧和经过32BIT循环冗余校验码CRC的计算检查后的等待时间。</li></ol><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>交换机可以认为是网桥的全方位加强版：同样通过自学习维护转发表确定数据帧转发的目的端口，用来隔离冲突域，每个与交换机的一个物理端口相连的LAN就是一个冲突域。但交换机拥有更多物理端口从而支持更多网段，其多组端口并行工作以及通过ASIC硬件芯片转发从而具有更强的转发能力(数据帧处理能力、传输速率)。</p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><hr><h3 id="基本原理-3"><a href="#基本原理-3" class="headerlink" title="基本原理"></a>基本原理</h3><p>路由器(Router)负责网络层的数据中继。它能够理解数据包头部字段中的IP地址(又称为网络地址，或者相对于MAC地址被称为物理地址，也可称作是逻辑地址)，如果它接收到一个数据包，就会首先检查其中的IP地址，查询其维护的路由表(Routing Table)中对应表项，如果目标地址是本地网络的就不予理会，而如果是在其它网络中的某台主机，就把该数据包转发出本地网络。</p><h3 id="核心功能-2"><a href="#核心功能-2" class="headerlink" title="核心功能"></a>核心功能</h3><p>路由器的作用在于连接不同类型(相同当然可以)的网络，并且能够在网络中通过运行路由算法为数据包传输找出最合适的路径(代价最小)，这一过程称作“路由选择”。</p><p>路由器的存储器里存放着路由表，这些表是易失的并且容易改变，路由表项的内容包括目的地址的下一跳(Next Hop)的路由地址，不同地址的距离等。这些内容都是路由器启动后经过学习得到的。路由器启动之后便根据设定的路由协议与其它路由器交换信息，在交换信息的过程中，学习路由并填充路由表。</p><p>因此，路由器虽然是基于硬件转发数据包的专用网络设备，但是路由器上配置支持的路由算法才是最核心的东西。</p><h3 id="选路算法"><a href="#选路算法" class="headerlink" title="选路算法"></a>选路算法</h3><p>选路/路由算法分为两大类：</p><ol><li><p>距离向量算法(Distance Vector Algorithm， 即DV算法)</p><ul><li>RIP(Routing Information Protocol，路由信息协议)</li><li>IGRP(Interior Gateway Routing Protocol，内部网关路由协议)</li></ul></li><li><p>链路状态算法(Link State Algorithm，即LS算法)</p><ul><li>OSPF(Open Shortest Path First Interior Gateway Protocol，开放式最短路径优先内部网关协议 )</li></ul></li></ol><p>还有一种综合两种算法的混合路由方案，如EIGRP(Enhanced Interior Gateway Routing Protocol，加强型内部网关路由协议)。</p><p>路由器使用距离矢量算法，判断到达目的地址的优先路径的标准就只有一个，那就是跳数，认为具有最小跳数的路径是最短/优路径，而不理会其带宽，可靠性，时延等因素。并且认为跳数大于15跳的目的地址是不可到达的。</p><p>另外，路由还有一个二层设备不具有的功能，那就是隔绝广播，它可以将广播限制在一个网络之内，进而增大网络之间的带宽。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>路由器工作在网络层，负责连接不同类型的网络，构造广域网(Wide Area Network, WAN)，隔离广播域，根据数据包的IP地址查找路由表对应表项完成转发。</p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>网关（Gateway）负责网络层以上的数据中继服务，实现不同体系结构的网络协议转换，它通常采用<strong>软件</strong>的方法实现，并且与特定的应用服务一一对应。比如：OSI的文件传输服务FTAM与TCP/IP的文件传输服务FTP，尽管二者都是文件传输但是由于所执行的协议不同不能直接进行通信，而需要网关将两个文件传输系统互连，达到相互进行文件传输的目的。 </p><p>网关是一种复杂的网络连接设备，可以支持不同协议之间的转换，实现不同协议网络之间的互连。<strong>网关具有对不兼容的高层协议进行转换的能力，为了实现异构设备之间的通信，网关需要对不同的链路层、专用会话层、表示层和应用层协议进行翻译和转换</strong>。所以网关兼有路由器、网桥、中继器的特性。</p><p>若要使两个完全不同的网络(异构网)连接在一起，一般使用网关，在Internet中两个网络也要通过一台称为网关的计算机实现互联。这台计算机能根据用户通信目标计算机的IP地址，决定是否将用户发出的信息送出本地网络，同时，它还将外界发送给属于本地网络计算机的信息接收过来，它是一个网络与另一个网络相联的通道。为了使TCP/IP协议能够寻址，该通道被赋予一个IP地址，这个IP地址称为网关地址。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>网关的作用就是将两个使用不同协议的网络段连接在一起的设备，对两个网络段中的使用不同传输协议的数据进行互相的翻译转换。在互连设备中，由于协议转换的复杂性，一般只能进行一对一的转换，或是少数几种特定应用协议的转换。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><hr><p>[1] <a href="http://blog.csdn.net/gongda2014306/article/details/52442981" target="_blank" rel="external">网络设备解析：中继器、集线器、网桥、交换机、路由器、网关的区别</a><br>[2] <a href="http://blog.csdn.net/u012243115/article/details/47008903" target="_blank" rel="external">转发器、集线器、网桥、交换机、路由器和网关简介</a><br>[3] <a href="http://blog.csdn.net/zhongyou2009/article/details/4768807" target="_blank" rel="external">交换机和网桥的区别</a><br>[4] <a href="http://hextwolf.blog.51cto.com/59501/29696" target="_blank" rel="external">广播域与冲突域详细解析</a><br>[5] <a href="http://www.nowamagic.net/academy/detail/72150314" target="_blank" rel="external">集线器、交换机和路由器通俗点的解释</a><br>[6] <a href="http://www.eepw.com.cn/article/275540.htm" target="_blank" rel="external">交换机工作原理</a><br>[7] <a href="http://blog.sina.com.cn/s/blog_5e1a889d0101370d.html" target="_blank" rel="external">交换机的工作原理(二、三、四层交换原理)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;全文概要&quot;&gt;&lt;a href=&quot;#全文概要&quot; class=&quot;headerlink&quot; title=&quot;全文概要&quot;&gt;&lt;/a&gt;全文概要&lt;/h2&gt;&lt;p&gt;计算机网络往往由多种不同类型的网络通过特殊的设备相互连接而成，本文简要介绍了转发器、集线器、网桥、桥接器、交换机、路由器等多种网络互连设备的功能原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="dongdongdong.me/categories/Network/"/>
    
    
      <category term="Interconnect" scheme="dongdongdong.me/tags/Interconnect/"/>
    
      <category term="Switch" scheme="dongdongdong.me/tags/Switch/"/>
    
      <category term="Router" scheme="dongdongdong.me/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>P4学习笔记：背景起源与基本原理</title>
    <link href="dongdongdong.me/2017/10/28/Network/SDN/P4/backgound/"/>
    <id>dongdongdong.me/2017/10/28/Network/SDN/P4/backgound/</id>
    <published>2017-10-28T02:29:26.000Z</published>
    <updated>2017-11-27T14:28:33.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全文概要"><a href="#全文概要" class="headerlink" title="全文概要"></a>全文概要</h2><p>软件定义网络(<a href="https://en.wikipedia.org/wiki/Software-defined_networking" target="_blank" rel="external"><strong>Software Defined Network, SDN</strong></a>)核心在于网络转发设备的数据转发平面(<strong>Data Plane</strong>)和控制平面(<strong>Control Plane</strong>)的分离和解耦，以实现可编程按需定制、集中式统一管理、动态流量监控、自动化部署。2014年<a href="https://p4.org/" target="_blank" rel="external"><strong>P4</strong></a>语言横空出世，进一步提高了面向交换机编程的可行性和效率，成为SDN领域的又一里程碑式的成果。本文从宣告P4诞生的<a href="https://www.sigcomm.org/" target="_blank" rel="external"><strong>SIGCOMM</strong></a>会议论文出发，介绍其背景起源、基本原理以及未来广阔的应用前景。<br><a id="more"></a></p><h2 id="行业趋势"><a href="#行业趋势" class="headerlink" title="行业趋势"></a>行业趋势</h2><hr><p><strong>SDN is the future, and P4 defines it.<br>SDN是未来，P4定义未来。</strong></p><h2 id="相关论文"><a href="#相关论文" class="headerlink" title="相关论文"></a>相关论文</h2><hr><p>Proposed in <a href="https://www.sigcomm.org/publications/computer-communication-review" target="_blank" rel="external">SIGCOMM Communication Review[J]</a>, 2014.<br>-<a href="https://arxiv.org/pdf/1312.1719.pdf" target="_blank" rel="external"><strong>《P4: Programming Protocol-Independent Packet Processors》</strong></a></p><h2 id="背景起源"><a href="#背景起源" class="headerlink" title="背景起源"></a>背景起源</h2><hr><p>P4是由P.Bosshart等人提出的一种用于处理数据包转发的高层抽象语言，协议独立(<strong>Protocol-Independent</strong>)是其核心特点，如OpenFlow一样是一种<a href="https://zhuanlan.zhihu.com/p/26743952" target="_blank" rel="external"><strong>南向协议</strong></a>，但是其应用范围要比OpenFlow还要大：不仅可以指导数据流转发，更提供了对交换机等网络转发设备的SDN数据平面的编程接口，实现了在设备层对数据处理流程进行软件定义，是真正意义上的软件定义网络。</p><p>就如论文中所说：</p><blockquote><p>We propose P4 as a strawman proposal for how OpenFlow should evolve in the Future.</p></blockquote><p>目前，P4语言作为一种潜在的<strong>OpenFlow2.0</strong>的发展方向在努力。</p><p>与华为<a href="http://www.poforwarding.org" target="_blank" rel="external"><strong>POF(Protocol Oblivious Forwarding)</strong></a>提出目的类似，P4的提出的目的也是为了解决OpenFlow可编程能力不足及其协议设计本身所带来的高复杂度(<strong>Complexity</strong>)和较差可扩展性(<strong>Scalability</strong>)的难题。</p><p>自从OpenFlow 1.0发布以来，其版本目前已演进到<a href="https://www.opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.5.1.pdf" target="_blank" rel="external"><strong>1.5</strong></a>，为了兼容多种不同的网络协议，使OpenFlow交换机能够处理具有不同头部的数据包，其匹配域(<strong>Header Field</strong>)的个数从1.0版本的12元组，变成1.3版本的40个，到最新1.5版本的45个，其匹配域数目随着新版本支持特性的更新不断增加，OpenFlow匹配域个数随版本演变情况具体见下表：</p><style>   table th:nth-of-type(1) {      width: 150px;   }</style><style>  table th:nth-of-type(2) {      width: 150px;}</style><table><thead><tr><th style="text-align:center">Version</th><th style="text-align:center">Date</th><th style="text-align:center">Header Fields</th></tr></thead><tbody><tr><td style="text-align:center">OF 1.0</td><td style="text-align:center">Dec 2009</td><td style="text-align:center">12 fields(Ethernet, TCP/IPv4)</td></tr><tr><td style="text-align:center">OF 1.1</td><td style="text-align:center">Feb 2011</td><td style="text-align:center">15 fields(MPLS, inter-table metadata)</td></tr><tr><td style="text-align:center">OF 1.2</td><td style="text-align:center">Dec 2011</td><td style="text-align:center">36 fields(ARP, ICMP, IPv6, etc)</td></tr><tr><td style="text-align:center">OF 1.3</td><td style="text-align:center">Jun 2012</td><td style="text-align:center">40 fields</td></tr><tr><td style="text-align:center">OF 1.4</td><td style="text-align:center">Oct 2013</td><td style="text-align:center">41 fields</td></tr><tr><td style="text-align:center">OF 1.5</td><td style="text-align:center">Dec 2014</td><td style="text-align:center">45 fields</td></tr></tbody></table><p>但OpenFlow本身并不支持弹性增加匹配域，因此每次增加一个匹配域就需要重新编写控制器(<strong>Controller</strong>)和交换机两端的协议栈，以及交换机的数据包处理逻辑，并分别烧制到OpenFlow控制器和交换机芯片上，这无疑大大增加了交换机设计的难度，高昂的更新成本也严重影响OpenFlow协议的版本稳定性，阻碍了OpenFlow的推广。</p><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><hr><p>根据论文所述，P4致力于实现以下三个目标：</p><ol><li><p><strong>可重配置性(Reconfigurability)</strong></p><blockquote><p>Programmers should be able to change the way switches process packets once they are deployed.</p></blockquote><p> 可灵活定义转发设备数据处理流程，且能够做到转发无中断的重配置。OpenFlow能够在已经固化在交换机上的数据处理逻辑之上，通过流表项指导数据流转发处理，而无法重新定义交换机处理数据的逻辑，每次增加新的网络协议支持，都必须将相关设备宕机下线并重新配置后再重新部署上线，即无法在不中断其它数据包转发的情况下弹性支持新协议。而P4语言的<strong>卖点</strong>恰恰在于其拥有对交换机的数据平面，即数据包处理逻辑即时编程的能力。</p></li><li><p><strong>协议无关性(Protocol-Independence)</strong></p><blockquote><p>Switches should not be tied to any specific network protocols.</p></blockquote><p> 交换机等转发设备无需关心协议语法和语义等内容，依然能够完成数据转发任务。这是使用P4可以自定义数据处理逻辑，并通过控制器对交换机等转发设备编程配置实现对应的协议处理逻辑，而这个行为(<strong>Behavior</strong>)将被翻译成对应的匹配(<strong>Match</strong>)和动作(<strong>Action</strong>)，从而被转发设备理解和执行。</p></li><li><p><strong>目标设备无关性(Target-Independence)</strong></p><blockquote><p>Programmers should be able to describe packet-processing functionality independently of the underlying hardware.</p></blockquote><p> 正如写C和Java(CPU-oriented Languauge，面向CPU编程语言)代码时并不需要了解CPU的相关信息(型号、参数等等硬件细节)，使用P4语言进行网络编程同样无需关心底层转发设备的具体信息。P4的编译器(Compiler)会将通用的P4语言处理逻辑翻译成设备所能理解的机器指令，并将其写入转发设备，完成配置和编程。</p></li></ol><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><hr><h3 id="转发模型-Forwarding-Model"><a href="#转发模型-Forwarding-Model" class="headerlink" title="转发模型(Forwarding Model)"></a>转发模型(Forwarding Model)</h3><p>论文中提出的数据包转发抽象模型如下图所示，交换机通过一个可编程的解析器(<strong>Parser</strong>)以及其后紧跟的多个”匹配-动作”操作阶段，或顺序，或并行，或组合两种模式，完成数据包的转发任务。</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/P4/forwarding-model.png"><p>模型概括了数据包是如何在<strong>不同转发设备</strong>(包括：以太网交换机、负载均衡器、路由器)中，通过<strong>不同技术</strong>(包括：固定功能交换机ASIC芯片、网络处理器(Network Processor Unit，NPU)、现场可编程门阵列(Field Programmable Gate Array，FPGA)、可重配置交换机、软件交换机)处理的。</p><p>基于此转发模型，设计出P4这样一种数据平面编程语言，用于描述数据包处理逻辑。从此，开发人员只需编写高层抽象的目标无关(<strong>Target-Inpendent</strong>)的P4程序，而无需关心底层设备细节，编译器会负责将程序映射到不同的底层转发设备，支持设备的种类范围从转发相对较慢的软件交换机到最快的基于ASIC的交换机，编译器都能将P4程序最终翻译成设备能理解并执行的机器指令。</p><p>转发模型由两种类型的操作所控制：</p><ol><li><strong>配置(Configure)</strong>：对解析器编程，设置各个匹配-动作阶段的执行顺序，并且指定每个阶段应处理的头部字段；</li><li><strong>部署(Populate)</strong>：动态增加、删除在配置阶段创建的匹配-动作表中的条目(<strong>Entry</strong>)。</li></ol><p><strong>配置操作(Configuration)</strong>决定了网络转发设备所支持的协议和数据包处理的逻辑，而<strong>部署操作(Population)</strong>决定了在给定时间内对数据包应用的处理策略(<strong>Policy</strong>)。配置与部署实际被设计成两个不同的阶段(<strong>Phase</strong>)，在配置阶段交换机不需要能够处理数据包，但是需要在部分或者全部重新配置(<strong>Reconfigure</strong>)阶段依然能够做到无宕机，即无中断的数据包处理。</p><p>根据转发模型，数据包到达交换机后，先由解析器处理，由于匹配阶段只需要头部信息(<strong>Packet Header</strong>)，故将数据体(<strong>Packet Body</strong>)先分别缓存。解析器识别并提取出特定头部字段，这实际定义了交换机支持的协议类型，在这些字段上面，会执行匹配操作，并根据匹配结果执行相关动作。</p><p>被提取的字段随后被传送给匹配-动作表，表被分成两个部分：入口表(<strong>Ingress Table</strong>)和出口表(<strong>Egress Table</strong>)。两者都可能会修改数据包头部，入口表决定了数据包的输出端口及其应该被放置的队列。被入口表处理时，数据包可能会被转发、复制(多播、发送至控制平面)、丢弃或触发流量控制。出口表执行对数据包头部的修改，如针对多播数据包的修改。</p><p>在不同处理阶段之间，数据包还可以携带额外信息，称作”元数据“，常见的元数据例如：输入端口、目的地址、队列、时间戳和虚拟网络标识符等等。</p><p>排队机制(<strong>Queuing Discipline</strong>)则是借鉴了OpenFlow中的做法：一个动作将一个数据包映射到一个队列，每个队列都会接受某种在交换机配置阶段就选定的服务类型(<strong>Service Discipline，受限水平这里不太理解，还请指教～</strong>)的数据包。</p><h4 id="P4-VS-OpenFlow"><a href="#P4-VS-OpenFlow" class="headerlink" title="P4 VS OpenFlow"></a>P4 VS OpenFlow</h4><p>与OpenFlow相比，P4的设计有三个优点：</p><ol><li>P4可编程定制数据解析流程，即<strong>Programmable Parser</strong>，而OpenFlow交换机只支持固定的包处理解析逻辑，即<strong>Fixed Parser</strong>；</li><li>P4可执行串行(<strong>Serial</strong>)和并行(<strong>Parallel</strong>)的Match-Action操作，而OpenFlow仅支持串行操作；</li><li>由于P4模型包含程序编译器，负责完成将P4程序到具体交换设备配置的映射，从而支持协议无关的转发，而OpenFlow支持的协议需要在初始时配置，此后每次修改都需要宕机，编写新的协议数据包处理逻辑再配置到交换机，不能做到无转发中断的弹性增加所支持的协议。</li></ol><img src="http://oyj8xdeki.bkt.clouddn.com/images/P4/P4vsOpenFlow.png"><h3 id="核心部件-Key-Component"><a href="#核心部件-Key-Component" class="headerlink" title="核心部件(Key Component)"></a>核心部件(Key Component)</h3><h4 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部(Header)"></a>头部(Header)</h4><p>对数据包的处理都需要根据包头的字段内容来决定对其采取什么操作，所以在P4程序中需要定义对应的包头。</p><blockquote><p>A header definition describes the sequence and structure of a series of  fields. It includes specification of field widths and constraints on field values.</p></blockquote><p>包头本质上就是有序排列的字段序列，包头由有序的字段名称即对应的字段长度组成，其中以太网和VLAN的包头格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">header ethernet &#123;</div><div class="line">    fields &#123;</div><div class="line">        dst_addr : <span class="number">48</span>; <span class="comment">// width in bits</span></div><div class="line">        src_addr : <span class="number">48</span>;</div><div class="line">        ethertype : <span class="number">16</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">header vlan &#123;</div><div class="line">    fields &#123;</div><div class="line">        pcp : <span class="number">3</span>;</div><div class="line">        cfi : <span class="number">1</span>;</div><div class="line">        vid : <span class="number">12</span>;</div><div class="line">        ethertype : <span class="number">16</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面是一个称作<strong>mTag</strong>的头部定义，它能够在数据包被处理的过程中在不影响已有字段声明的情况下被添加至其头部，携带额外的处理信息，作为我们的一个P4程序的完整实例的一部分引入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">header mTag &#123;</div><div class="line">    fields &#123;</div><div class="line">        up1: <span class="number">8</span>;</div><div class="line">        up2: <span class="number">8</span>;</div><div class="line">        down1: <span class="number">8</span>;</div><div class="line">        down2: <span class="number">8</span>;</div><div class="line">        ethertype: <span class="number">16</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="解析器-Parser"><a href="#解析器-Parser" class="headerlink" title="解析器(Parser)"></a>解析器(Parser)</h4><p>在定义了包头之后，还需要定义头部字段之间的关系，及数据包解析的对应关系。</p><blockquote><p>A parser definition specifies how to identify headers and valid header sequences within packets.</p></blockquote><p>比如以太网头部的<strong>ethertype</strong>字段在等于<strong>0x0800</strong>时应该继续跳转至IPv4的头部进行后续解析。下面仍以以太网头部解析(<strong>parser ethernet</strong>表示本解析器专门用来解析以太网头部)为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">parser ethernet &#123;</div><div class="line">    <span class="keyword">switch</span>(ethertype)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x8100</span>: vlan;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x9100</span>: vlan;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x0800</span>: ipv4;</div><div class="line">        <span class="comment">// Other cases</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>P4假设底层交换机能实现一个从头到尾遍历数据包头部的状态机(<strong>State Machine</strong>)，并在该遍历过程中依次提取(<strong>Extract</strong>)出头部各字段内容，这些字段内容最终会被送到下面介绍的Match-Action表中统一处理。</p><p>P4将此状态机描述为一个从一个头部字段到下一个头部字段的转换(<strong>Transition</strong>)的集合，每次转换由当前头部字段的具体取值所触发。下面我们会描述一个<strong>mTag</strong>状态机：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">parser start &#123;</div><div class="line">    ethernet;</div><div class="line">&#125;</div><div class="line"></div><div class="line">parser ethernet &#123;</div><div class="line">    <span class="keyword">switch</span>(ethertype)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x8100</span>: vlan;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x9100</span>: vlan;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x0800</span>: ipv4;</div><div class="line">        <span class="comment">// Other cases</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">parser vlan &#123;</div><div class="line">    <span class="keyword">switch</span>(ethertype)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">0xaaaa</span>: mTag;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x0800</span>: ipv4;</div><div class="line">        <span class="comment">// Other cases</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">parser mTag &#123;</div><div class="line">    <span class="keyword">switch</span>(ethertype) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x0800</span>: ipv4;</div><div class="line">        <span class="comment">// Other cases</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意，所有的解析均从start状态开始，并在到达stop状态或出错之后结束。解析器用于将字节流数据解析为对应的协议报文，用于后续的流表项匹配和动作执行。</p><p>一旦解析来到一个新的头部，即到达一个新状态，状态机利用其配置信息(<strong>Specification</strong>)将头部提取出来，并确定其下一次转换。被提取出的头部被转发至交换机流水线后半段执行的Match-Action操作处理。</p><h4 id="匹配-动作表-Match-Action-Table"><a href="#匹配-动作表-Match-Action-Table" class="headerlink" title="匹配-动作表(Match-Action Table)"></a>匹配-动作表(Match-Action Table)</h4><p>P4中需要定义多种类型用途的表用于存储匹配表项，格式为Match+Action，即匹配域(头部部分字段的组合)和对应的执行动作。P4语言定义某个表具体的匹配域及需要执行的动作。而具体的流表项会在网络运行过程中通过控制器来编程下发，从而完成对应数据流的处理。因此，匹配-动作表，实际定义或决定了相关数据包的处理逻辑。</p><blockquote><p>Match+action tables are the mechanism for performing packet processing. The P4 program defines the fields on which a table may match and the actions it may execute.</p></blockquote><p>接着上文中<strong>mTag</strong>的例子，边缘交换机(<strong>Edge Switch</strong>)会匹配二层目的地址(数据链路层目的地址，即目的MAC地址)和VLAN ID，并且将<strong>mTag</strong>添加到数据包头部, 从而数据包在交换网络中就可以通过匹配<strong>mtag</strong>来完成转发。下面P4程序定义了一个表来<strong>匹配</strong>上述字段，并且对数据包应用一个添加<strong>mTag</strong>头部的<strong>动作</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">table mTag_table &#123;</div><div class="line">    reads &#123;</div><div class="line">        ethernet.dst_addr: exact;</div><div class="line">        vlan.vid: exact;</div><div class="line">    &#125;</div><div class="line">    actions &#123;</div><div class="line">        <span class="comment">// At runtime, entries are programmed with params</span></div><div class="line">        <span class="comment">// for the mTag action, see below.</span></div><div class="line">        add_mTag;</div><div class="line">    &#125;</div><div class="line">    max_size: <span class="number">20000</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>表中各属性意义如下：</p><ul><li><strong>reads</strong>：声明匹配域，即需要匹配的字段，由匹配类型量化，包括：<strong>exact</strong>(精确匹配，完全匹配)、<strong>ternary</strong>、<strong>ranges</strong>(一定范围内)、wildcard(通配符)；</li><li><strong>actions</strong>: 列举本表可能对被匹配的数据包采取的动作，动作会在下一小节重点阐述；</li><li><strong>maxsize</strong>: 规定本表所能支持的最大条目容量。</li></ul><p>为了在后文继续讨论<strong>mTag</strong>的后续处理流程，还定义了如下三个表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">table source_check &#123;</div><div class="line">    <span class="comment">// Verify mtag only on ports to the core</span></div><div class="line">    reads &#123;</div><div class="line">        mtag: valid; <span class="comment">// Was mtag parsed?</span></div><div class="line">        metadata.ingress_port: exact;</div><div class="line">    &#125;</div><div class="line">    actions &#123;</div><div class="line">        <span class="comment">// Each table entry specifies one action</span></div><div class="line"></div><div class="line">        <span class="comment">// If inappropriate mTag, send to CPU</span></div><div class="line">        fault_to_cpu;</div><div class="line"></div><div class="line">        <span class="comment">// If mtag found, strip and record in metadata</span></div><div class="line">        strip_mtag;</div><div class="line"></div><div class="line">        <span class="comment">// Otherwise, allow the packet to continue</span></div><div class="line">        pass;</div><div class="line">    &#125;</div><div class="line">    max_size: <span class="number">64</span>; <span class="comment">// One rule per port</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">table local_switching &#123;</div><div class="line">    <span class="comment">// Reads destination and checks if local</span></div><div class="line">    <span class="comment">// If miss occurs, goto mtag table</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">table egress_check &#123;</div><div class="line">    <span class="comment">// Verify egress is resolved</span></div><div class="line">    <span class="comment">// Do not retag packets received with tag</span></div><div class="line">    <span class="comment">// Reads egress and whether packet was mTagged</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="动作-Action"><a href="#动作-Action" class="headerlink" title="动作(Action)"></a>动作(Action)</h4><p>与OpenFlow的动作类似，不过P4程序中的动作是抽象程度更高的协议无关的操作。P4定义了一套协议无关的原始指令集(<strong>Primitive</strong>，原语)，基于该指令集可以实现复杂的协议操作，这可以通过赋予不同的参数来调用这些原始指令集组合来实现，而这些参数还可以是数据包匹配过程中产生的元数据。</p><p>P4假定一个动作函数(<strong>Action Function</strong>)里的原语都是可并行执行的，而原本不支持并行的交换机则可以通过仿真来实现类似效果(缺乏对交换机硬件结构的详细理解，暂留疑问，欢迎指教～)。</p><blockquote><p>P4 supports construction of complex actions from simpler protocol-independent primitives. These complex actions are available within match+action tables.</p></blockquote><p>上文提到的<strong>add_mTag</strong>动作用P4表述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">action <span class="title">add_mTag</span><span class="params">(up1, up2, down1, down2, egr_spec)</span> </span>&#123;</div><div class="line">    add_header(mTag);</div><div class="line">    <span class="comment">// Copy VLAN ethertype to mTag</span></div><div class="line">    copy_field(mTag.ethertype, vlan.ethertype);</div><div class="line">    <span class="comment">// Set VLAN's ethertype to signal mTag</span></div><div class="line">    set_field(vlan.ethertype, <span class="number">0xaaaa</span>);</div><div class="line">    set_field(mTag.up1, up1);</div><div class="line">    set_field(mTag.up2, up2);</div><div class="line">    set_field(mTag.down1, down1);</div><div class="line">    set_field(mTag.down2, down2);</div><div class="line"></div><div class="line">    <span class="comment">// Set the destination egress port as well</span></div><div class="line">    set_field(metadata.egress_spec, egr_spec);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从以上程序可以看出<strong>mTag</strong>动作的执行流程：交换机将<strong>mTag</strong>插入到<strong>VLAN tag</strong>之后，将<strong>VLAN tag</strong>的<strong>ethertype</strong>赋值给<strong>mTag</strong>的对应字段从而暗示(Indicate)后面接的字段是<strong>VLAN</strong>头部，然后将<strong>VLAN tag</strong>的<strong>ethertype</strong>赋值为<strong>0xaaaa</strong>来唤醒<strong>parser mTag</strong>处理<strong>mTag</strong>这个新增头部。</p><p>P4支持的原语动作集包括：</p><ul><li><strong>set_field</strong>：为头部中某个特定字段赋值；</li><li><strong>copy_field</strong>：将参数二的字段值赋给参数一代表的字段；</li><li><strong>add_header</strong>：将一个特定的头部实例(或其包含的全部字段)设为有效(valid)的；</li><li><strong>remove_header</strong>：从一个数据包删除其头部(或其头部包含的全部字段)；</li><li><strong>increment</strong>：增加或减小一个字段的值；</li><li><strong>checksum</strong>：为一个字段集合计算校验和(如IPv4头部，根据其全部字段计算校验和)。</li></ul><h4 id="控制程序-Control-Program"><a href="#控制程序-Control-Program" class="headerlink" title="控制程序(Control Program)"></a>控制程序(Control Program)</h4><p>一旦表和动作都已完成定义，剩下的任务就是指定从一个表到下一个表的控制流。在P4程序中，控制流通过一系列函数(<strong>Functions</strong>)、条件(<strong>Conditionals</strong>)和表引用(<strong>Table References</strong>)来指定。</p><blockquote><p>The control program determines the order of match+action tables that are applied to a packet. A simple imperative program describe the flow of control between match+action tables.</p></blockquote><p>控制程序决定了数据包处理阶段的具体顺序，即数据包在不同匹配表中间的跳转关系。当表和动作被定义和实现之后，还需要控制程序来确定不同表之间的控制流。P4的控制流包括用于数据处理的表、判决条件以及条件成立时所需采取的操作等组件。</p><p>下图显示了在边缘交换机上<strong>mTag</strong>包处理逻辑示例的控制流：</p><img src="http://oyj8xdeki.bkt.clouddn.com/images/P4/flow-for-mTag.png"><p>被解析(<strong>parser mTag</strong>)之后的数据包，先进入<strong>source_check</strong>表，验证接收到的包和进入端口(Ingress Port)是否和表中的匹配要求一致，即数据包是否包含<strong>mTag</strong>头部，进入端口是否与核心交换机相连。根据该表中的<strong>reads</strong>属性匹配到对应数据包后，由<strong>action</strong>属性指定要采取的动作是：<strong>strip_tag</strong>，即将<strong>mTag</strong>头部从数据包中剥落，并将该数据包是否包含<strong>mTag</strong>头部记录在元数据中，流水线后部分的表可能还会匹配到该元数据，从而避免再次给该数据包打上<strong>mTag</strong>。</p><p>之后<strong>local_switching</strong>表被执行，如果该表未能成功匹配，发生了<strong>misses</strong>，则表示该数据包的目的地不是一个与本交换机相连的主机，这时候就需要执行<strong>mTag_table</strong>。而无论本地局部转发(边缘交换机)还是核心转发(核心交换机)，控制流都会进入<strong>egress_check</strong>表，用于处理发往未知目的地的数据包，它会向SDN控制栈发送一个通知。</p><p>综上，可以将数据包处理流水线表示成如下P4程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">control <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Verify mTag state and port are consistent</span></div><div class="line">    table(source_check);</div><div class="line"></div><div class="line">    <span class="comment">// If no error from source_check, continue</span></div><div class="line">    <span class="keyword">if</span>(!defined(metadata.ingress_error)) &#123;</div><div class="line">        <span class="comment">// Attempt to switch to end hosts</span></div><div class="line">        table(local_switching);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!defined(metadata.egress_spec)) &#123;</div><div class="line">            <span class="comment">// Not a known local host; try mtagging</span></div><div class="line">            table(mTag_table);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Check for unknown egress state pr</span></div><div class="line">        <span class="comment">// bad retagging with mTag</span></div><div class="line">        table(egress_check);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="编译器-Compiler"><a href="#编译器-Compiler" class="headerlink" title="编译器(Compiler)"></a>编译器(Compiler)</h3><p>编写P4程序的五个基本组件后，接下来就需要使用编译器将程序编译并写入到交换机中，其主要分为数据解析逻辑的编译写入和控制流程编译写入。</p><p>数据解析部分用于将网络字节流解析为对应的协议报文，并将报文送到接下来的控制流程中进行匹配和处理。</p><p>控制流程的编译和写入则分为以下两步：</p><ol><li>将P4程序编译，生成设备无关的表依赖图(<strong>Table Dependency Graph, TDG</strong>)；</li><li>根据特定的底层转发设备的资源和能力，将表依赖图映射到转发设备的资源上。</li></ol><p>目前P4程序可在软件交换机、拥有RAM和TCAM存储设备的硬件交换机、支持并行表处理的交换机、支持在流水线最后阶段才执行动作的交换机以及拥有少量表资源的交换机等多种交换设备上实现。</p><h3 id="工作流-Work-Flow"><a href="#工作流-Work-Flow" class="headerlink" title="工作流(Work Flow)"></a>工作流(Work Flow)</h3><ol><li>数据包到来后，首先进入可编程定制(<strong>Programmable</strong>)的解析器，用于实现自定义的数据解析流程(针对头部字段，可将网络字节流解析成对应的协议数据包；</li><li><p>数据包解析完毕后是与OpenFlow类似的匹配-动作操作，其流水线(<strong>Pipeline</strong>)支持串行和并行两种模式。受OpenFlow 1.4启发，P4设计的匹配过程也分为入口流水线(<strong>Ingress Pipeline</strong>)和出口流水线(<strong>Egress Pipeline</strong>)两个分离的数据处理流水线；</p></li><li><p>在定义交换机的处理逻辑时，需要定义数据包处理的依赖关系(<strong>Dependency</strong>)，即数据包头部字段之间的依赖关系，比如要处理IPv4头部字段，可能需要依赖于以太网头部字段的处理。这些依赖关系可以通过P4描述出来，并编译生成表依赖图TDG，其中每个表都是对应的一种协议或者一个类别的数据包的处理。TDG描述了匹配表之间的逻辑关系，输入和对应操作等行为，用于指导交换机进行数据处理。TDG被定义出来之后，将被编译器翻译成交换机所能理解的逻辑(机器指令)，并写入到交换机等交换实体中去，从而完成自定义的数据包处理流程。</p></li></ol><h2 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h2><hr><p>下面一段话引自原作者<a href="http://www.muzixing.com" target="_blank" rel="external"><strong>李呈</strong></a>学长，作为正欲入门SDN的小白，正准备拜读其书<a href="http://item.jd.com/12160066.html" target="_blank" rel="external"><strong>《重构网络：SDN架构与实现》</strong></a>，就顺便安利一下吧～</p><blockquote><p>OpenFlow协议目前的框架设计使得OpenFlow无法对转发设备的数据解析以及处理流程进行编程实现，缺少足够的可编程能力。此外，由于OpenFlow的匹配项均为协议相关的，使得每增加一个匹配域均需要对协议栈以及交换机处理流程进行重新编程，而这个过程周期很长，为支持新的OpenFlow协议需要对现有交换机进行升级或者推出新的交换机产品。这样的缺点让OpenFlow协议版本难以稳定，也难以推广。服务提供商在建设网络基础设施时，需要考虑支持OpenFlow什么版本，也要担心未来OpenFlow协议推出新版本时的兼容和设备升级等问题，使得OpenFlow迟迟无法大规模应用。面对OpenFlow的缺陷，P4的推出刚好解决了这个难题。</p><p>P4语言支持对交换机处理逻辑进行编程定义，从而使得协议版本在更新迭代时无需购买新设备，只需通过控制器编程更新交换机处理逻辑即可。这种创新解决了OpenFlow编程能力不足，版本不稳定的问题。此外，由于P4可以编程定义交换机处理逻辑，从而使得交换机可以实现协议无关的转发，进而使得底层交换机更加白盒化，适用范围更广，更容易降低设备采购成本。而且作为一门编程语言，P4支持设备无关特性，使得P4可以应用在不同厂家生产的转发设备上，解除了服务提供商对网络设备厂家绑定的顾虑。</p><p>自P4诞生以来，得到了业界的关注和认可，目前发展良好。作为一门网络编程语言，其大大简化了网络编程的难度，同时也改善了目前SDN可编程能力不足的问题。P4的主要推动者Nick教授是当下SDN最流行的南向协议OpenFlow协议的发明者之一，Jennifer教授也在网络界的先驱。无论是处于对P4技术本身的认同，还是对Nick教授和Jennifer教授的认同，业界，尤其是学术界都对P4的应用前景十分看好，认为其将成为OpenFlow2.0的可能发展方向。目前，P4组织已经有了非常多的成员，其中不乏AT&amp;T、思科、华为、Intel、腾讯和微软等知名企业以及斯坦福大学，普林斯顿大学和康奈尔大学等多个全球顶尖的学术机构。此外，在P4发展的过程中，已经被多种转发设备支持，比如应用最广泛的软件交换机<a href="http://openvswitch.org/" target="_blank" rel="external"><strong>OpenVSwitch</strong></a>以及华为的POF交换机。转发设备硬件厂商的大力支持是P4继续发展的重要保障，也是P4商业发展的大前提。</p><p>P4的设计和华为提出的POF十分相似，只不过侧重点和实现方式不同。POF通过{offset,length}来确定数据，强调协议无关，强调指令集，而P4不仅有底层的高度抽象的协议无关指令集，更侧重与控制器端的网络编程语言的构建。还有一点不同的是，同作为开创式的技术，由美国Nick教授等业界先驱推动的P4明显要比由华为提出的POF受到的关注要多，业界对P4的认同也要比POF要高。</p><p>P4和POF相同之处在于：作为完全可编程的SDN实现，性能问题是两者需要面临的大问题，也是急需解决的技术难题。而商业因素方面，两者皆会打破目前的网络界生态平衡。选择搭上这个技术发展的顺风车并争取在新的技术领域占据有利地位，还是固守已有行业市场是网络厂商面连的艰难选择。完全可编程SDN的出现，将使网络的重点和热点进一步由硬件转向软件领域，从而使得依靠硬件技术壁垒占据市场有利地位的传统巨头的优势受到严重削减。虽然巨头的决策将很大程度上影响这些创新技术的发展，但是技术必然会朝着更好更优的方向发展，无论是P4还是POF，抑或是其他的解决方案，具有更好可编程性的SDN就在不远的未来。正如SDN的出现一般，是技术发展过程中顺势而为的产物，是不可阻挡的潮流。</p></blockquote><p>最后送上总结：<br><strong>SDN是未来，P4也势必将在未来的可编程SDN领域大有作为！</strong></p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><hr><p>[1] GitHub开源项目<a href="https://github.com/p4lang" target="_blank" rel="external"><strong>p4lang</strong></a><br>[2] 李呈前辈<a href="http://www.muzixing.com/pages/2016/03/23/p4zhen-zheng-de-sdnhuan-yao-yuan-ma.html" target="_blank" rel="external"><strong>博文</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;全文概要&quot;&gt;&lt;a href=&quot;#全文概要&quot; class=&quot;headerlink&quot; title=&quot;全文概要&quot;&gt;&lt;/a&gt;全文概要&lt;/h2&gt;&lt;p&gt;软件定义网络(&lt;a href=&quot;https://en.wikipedia.org/wiki/Software-defined_networking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Software Defined Network, SDN&lt;/strong&gt;&lt;/a&gt;)核心在于网络转发设备的数据转发平面(&lt;strong&gt;Data Plane&lt;/strong&gt;)和控制平面(&lt;strong&gt;Control Plane&lt;/strong&gt;)的分离和解耦，以实现可编程按需定制、集中式统一管理、动态流量监控、自动化部署。2014年&lt;a href=&quot;https://p4.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;P4&lt;/strong&gt;&lt;/a&gt;语言横空出世，进一步提高了面向交换机编程的可行性和效率，成为SDN领域的又一里程碑式的成果。本文从宣告P4诞生的&lt;a href=&quot;https://www.sigcomm.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;SIGCOMM&lt;/strong&gt;&lt;/a&gt;会议论文出发，介绍其背景起源、基本原理以及未来广阔的应用前景。&lt;br&gt;
    
    </summary>
    
      <category term="Network" scheme="dongdongdong.me/categories/Network/"/>
    
    
      <category term="P4" scheme="dongdongdong.me/tags/P4/"/>
    
      <category term="SDN" scheme="dongdongdong.me/tags/SDN/"/>
    
      <category term="Network Visualization" scheme="dongdongdong.me/tags/Network-Visualization/"/>
    
  </entry>
  
</feed>
